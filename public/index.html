<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MASS — Albums & Tracks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#0f0f12; --fg:#f5f6f7; --muted:#a7abb3; --card:#17181c; --accent:#62f5a9; --border:#24262c;
      --cover-size: 140px; /* smaller, tidy covers */
      --overlay: rgba(0,0,0,.6);
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;}
    header{padding:20px 16px;border-bottom:1px solid var(--border);position:sticky;top:0;background:linear-gradient(180deg,rgba(15,15,18,0.98),rgba(15,15,18,0.9));backdrop-filter:saturate(180%) blur(8px);z-index:10;}
    .title{font-size:28px;font-weight:800;letter-spacing:.3px;text-align:center;}
    .searchbar{max-width:960px;margin:12px auto 0;display:grid;grid-template-columns:minmax(0,1fr) minmax(0,0.8fr) repeat(4,auto);gap:8px;align-items:center;}
    .searchbar input{background:var(--card);color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:12px 14px;font-size:16px;outline:none;}
    .searchbar button{background:var(--accent);color:#0b1210;border:none;border-radius:10px;padding:12px 16px;font-weight:700;cursor:pointer;}
    .searchbar .status{grid-column:1 / -1;justify-self:flex-start;}

    main{max-width:1100px;margin:20px auto;padding:0 16px 40px;}
    .albums-grid{display:grid;grid-template-columns:repeat(1,minmax(0,1fr));gap:20px;margin-top:16px;}
    @media (min-width:640px){ .albums-grid{grid-template-columns:repeat(2,minmax(0,1fr));} }
    @media (min-width:1024px){ .albums-grid{grid-template-columns:repeat(3,minmax(0,1fr));} }

    .album-card{display:flex;flex-direction:column;height:100%;background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden;box-shadow:0 4px 12px rgba(0,0,0,.12);} 
    .album-cover{border:none;padding:0;margin:0;background:none;width:100%;aspect-ratio:1/1;cursor:pointer;position:relative;display:block;}
    .album-cover img{width:100%;height:100%;object-fit:cover;display:block;}
    .album-cover.no-image{display:flex;align-items:center;justify-content:center;background:#1f1f23;color:var(--muted);font-size:14px;font-style:italic;}
    .album-cover:focus-visible{outline:2px solid var(--accent);outline-offset:2px;}

    .album-body{padding:12px;display:flex;flex-direction:column;gap:6px;height:100%;}
    .album-title{margin:0;font-size:18px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;}
    .subtitle{color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px;}
    .album-meta{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    .album-actions{margin-top:auto;display:flex;gap:8px;}
    .album-actions .btn{flex:1;justify-content:center;}

    /* Cover: used inside track modal */
    .cover-wrap{position:relative;width:var(--cover-size);height:var(--cover-size);border-radius:10px;overflow:hidden;border:1px solid var(--border);background:#101215;margin:0 auto;}
    .cover-wrap img{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;}

    .muted{color:var(--muted);font-size:13px;text-align:center;}
    .badge{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:11px;color:var(--muted);}
    .badge.badge-invalid{background:#2b1517;border-color:#5a2327;color:#ffb1b8;font-weight:600;}

    .btn{background:transparent;border:1px solid var(--border);border-radius:10px;color:var(--fg);padding:8px 10px;cursor:pointer;}
    .btn.small{padding:6px 8px;font-size:13px;}
    .btn.icon{width:34px;display:inline-flex;align-items:center;justify-content:center;}
    .btn-accent{background:var(--accent);border-color:var(--accent);color:#0b1210;font-weight:700;}

    .toolbar{display:flex;align-items:center;justify-content:space-between;margin:10px 0;}
    .pager{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:18px;}
    .pager button{background:transparent;color:#f5f6f7;border:1px solid var(--border);border-radius:10px;padding:10px 12px;cursor:pointer;}
    .count{text-align:center;color:var(--muted);margin:6px 0 10px;font-size:14px;}
    .error{background:#2b1517;border:1px solid #5a2327;color:#ffb1b8;padding:10px 12px;border-radius:10px;}

    .decades{max-width:960px;margin:8px auto 0;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;}
    .decades button{background:#22252b;border:1px solid var(--border);color:var(--fg);border-radius:999px;padding:6px 10px;cursor:pointer;font-size:13px;}

    /* Landing placeholder */
    .landing{display:flex;align-items:center;justify-content:center;min-height:40vh;}
    .landing img{max-width:1000px;max-height:1000px;opacity:.9;display:block;}

    /* ======= Modal (centered track window) ======= */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:var(--overlay);z-index:100;}
    .overlay.open{display:flex;}
    .modal{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.35);width:min(900px,94vw);max-height:88vh;display:flex;flex-direction:column;overflow:hidden;}
    .modal header{display:flex;align-items:center;gap:12px;padding:12px 14px;border-bottom:1px solid var(--border);background:#14161a;position:sticky;top:0;z-index:1;}
    .modal .cover-wrap{width:56px;height:56px;margin:0;}
    .modal .meta{display:flex;flex-direction:column;gap:2px;min-width:0;}
    .modal h2{margin:0;font-size:18px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .modal .sub{color:var(--muted);font-size:13px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .modal .spacer{flex:1;}
    .modal .close{border:1px solid var(--border);background:transparent;border-radius:10px;color:var(--fg);padding:8px 10px;cursor:pointer;}
    .modal .content{padding:12px;overflow:auto;}
    .tracks{margin:0;padding:0;list-style:none;display:flex;flex-direction:column;gap:8px;}
    .track{background:#1f1f23;padding:8px 10px;border-radius:8px;display:flex;flex-direction:column;gap:6px;}
    .track-top{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .track .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .controls{display:flex;align-items:center;gap:6px;}
    .playing{outline:1px solid var(--accent); background:#202427;}
    .progress{display:flex;align-items:center;gap:8px;margin-top:6px;}
    .seek{appearance:none;width:240px;height:8px;background:linear-gradient(var(--accent),var(--accent)) 0/var(--fill,0%) 100% no-repeat,#1b2a21;border-radius:999px;outline:none;border:1px solid var(--accent);}
    .seek::-webkit-slider-thumb{appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);}
    .time{font-size:12px;color:var(--muted);min-width:98px;text-align:right;}
    .info{display:none;margin-top:2px;padding:8px 10px;border-radius:8px;background:#16181d;border:1px solid var(--border);color:#c9ccd3;font-size:13px;}
    .info-row{display:flex;gap:8px;margin:2px 0;}
    .info .label{min-width:110px;color:#e3e6ee;}
    .no-scroll{overflow:hidden;}

    /* Busy / searching status indicator */
    .status{display:inline-flex;align-items:center;gap:8px;margin-left:8px;color:var(--muted);font-size:13px;}
    .status[hidden]{display:none;}
    .status .pulse{width:8px;height:8px;border-radius:50%;background:var(--accent);
      box-shadow:0 0 0 0 rgba(98,245,169,.7);animation:pulse 1.3s infinite;}
    @keyframes pulse{
      0%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,.7);} 
      70%{transform:scale(1);box-shadow:0 0 0 10px rgba(98,245,169,0);} 
      100%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,0);} 
    }
    button:disabled{opacity:.6;cursor:not-allowed;}

    /* Track info modal */
    .info-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:200;}
    .info-modal-overlay.open{display:flex;}
    .info-modal{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px 20px;width:min(480px,92vw);max-height:80vh;overflow:auto;box-shadow:0 18px 48px rgba(0,0,0,.4);}
    .info-modal header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px;}
    .info-modal h3{margin:0;font-size:18px;}
    .info-modal .info-close{border:1px solid var(--border);background:transparent;color:var(--fg);border-radius:8px;padding:6px 10px;cursor:pointer;}
    .info-modal dl{margin:0;display:grid;grid-template-columns:minmax(120px,auto) 1fr;gap:10px 14px;font-size:14px;}
    .info-modal dt{font-weight:600;color:var(--muted);}
    .info-modal dd{margin:0;}
    .info-modal-empty{color:var(--muted);font-style:italic;text-align:center;margin:12px 0;}

  </style>
</head>
<body>
  <header>
    <img src="/img/MAD_Logo.png" alt="MAD Logo" style="display:block;margin:0 auto 10px;max-height:100px">
    <div class="searchbar">
      <input id="search" type="search" placeholder="Search albums, artists, tracks, year, genre…" autocomplete="off" />
      <input id="artist" type="search" placeholder="Artist" autocomplete="off" />
      <button id="go">Search</button>
      <button id="goArtist">Search Artist</button>
      <button id="clear">Clear</button>
      <button id="explore">Explore</button>
      <span id="status" class="status" hidden aria-live="polite" role="status"><span class="pulse"></span><span id="statusText">Searching…</span></span>
    </div>
    <div id="decades" class="decades" hidden></div>
  </header>
  <div id="codex-canary">Codex was here</div>

  <main>
    <div id="landing" class="landing" aria-hidden="false"></div>
    <div class="toolbar">
      <div id="count" class="count"></div>
    </div>
    <div id="albums" class="albums-grid"></div>
    <div id="pager" class="pager" hidden>
      <button id="prev">◀ Prev</button>
      <span id="pageInfo" class="badge">Page 1</span>
      <button id="next">Next ▶</button>
    </div>
    <div id="error" class="error" hidden></div>
  </main>

  <!-- Single centered modal (reused for all albums) -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <div id="modalCover" class="cover-wrap" aria-hidden="true"></div>
        <div class="meta">
          <h2 id="modalTitle">Album</h2>
          <div class="sub">
            <span id="modalArtist"></span>
            <span id="modalCat" class="badge"></span>
          </div>
        </div>
        <div class="spacer"></div>
        <button id="modalClose" class="close" aria-label="Close">✕</button>
          </header>
      <div id="modalContent" class="content"></div>
    </div>
  </div>

  <div id="trackInfoOverlay" class="info-modal-overlay" hidden>
    <div id="trackInfoDialog" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="trackInfoTitle">
      <header>
        <h3 id="trackInfoTitle">More info</h3>
        <button type="button" id="trackInfoClose" class="info-close">Close</button>
      </header>
      <div id="trackInfoBody"></div>
    </div>
  </div>

  <audio id="player" preload="none"></audio>

  <script>
    const albumsEl = document.getElementById('albums');
    const searchEl = document.getElementById('search');
    const artistEl = document.getElementById('artist');
    const clearEl  = document.getElementById('clear');
    const goEl  = document.getElementById('go');
    const goArtistEl = document.getElementById('goArtist');
    const pagerEl  = document.getElementById('pager');
    const prevEl   = document.getElementById('prev');
    const nextEl   = document.getElementById('next');
    const pageInfo = document.getElementById('pageInfo');
    const countEl  = document.getElementById('count');
    const errorEl  = document.getElementById('error');
    const player   = document.getElementById('player');
    const landingEl = document.getElementById('landing');
    const exploreEl = document.getElementById('explore');
    const decadesEl = document.getElementById('decades');

    // Modal elements
    const overlay = document.getElementById('overlay');
    const modalCover = document.getElementById('modalCover');
    const modalTitle = document.getElementById('modalTitle');
    const modalArtist = document.getElementById('modalArtist');
    const modalCat = document.getElementById('modalCat');
    const modalContent = document.getElementById('modalContent');
    const modalClose = document.getElementById('modalClose');
    const trackInfoOverlay = document.getElementById('trackInfoOverlay');
    const trackInfoDialog = document.getElementById('trackInfoDialog');
    const trackInfoBody = document.getElementById('trackInfoBody');
    const trackInfoClose = document.getElementById('trackInfoClose');

    // Config
    const ALBUMS_PER_PAGE = 9;
    const FM_FETCH_LIMIT  = 200; // UI asks for 200; FM may cap ~100 internally
    const ARTIST_FETCH_LIMIT = 9;
    const SHOW_TITLE_WARNING = false; // hide badge (logic retained if ever needed)

    // State
    let lastQ = '';
    let lastArtist = '';
    let currentEndpoint = '/api/search';
    let currentParams = {};
    let currentLimit = FM_FETCH_LIMIT;
    let inFlight = null;
    let typingTimer = null;
    let trackInfoReturnFocus = null;
    let trackInfoFocusables = [];
    const trackInfoFocusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

    // Busy status indicator
    const statusEl = document.getElementById('status');
    const statusTextEl = document.getElementById('statusText');
    let busyCount = 0;
    function showBusy(label='Searching…'){
      busyCount++;
      if (statusTextEl) statusTextEl.textContent = label;
      if (statusEl) statusEl.hidden = false;
      if (goEl) goEl.disabled = true;
      if (exploreEl) exploreEl.disabled = true;
    }
    function hideBusy(){
      busyCount = Math.max(0, busyCount - 1);
      if (busyCount === 0){
        if (statusEl) statusEl.hidden = true;
        if (goEl) goEl.disabled = false;
        if (exploreEl) exploreEl.disabled = false;
      }
    }


    // Raw FM rows (cumulative as we lazy-load)
    let rawItems = [];
    let rawTotalFound = 0;
    let rawNextOffset = 0; // UI 0-based; server converts to FM 1-based

    // Grouped albums & album-page state
    let albumGroups = [];
    let albumPage = 0;

    // Single audio UI state
    let currentBtn=null, currentRow=null, currentSrc='';

    // Field helper mappings (adjust here if exact names differ)
    function fCatalogue(f){
      return f['Album Catalogue Number'] || f['Album Catalog Number'] || f['Album Catalogue No'] || f['Catalogue'] || '';
    }
    function fPicture(f){
      return f['Artwork::Picture'] || f['Picture'] || f['Artwork Picture'] || '';
    }
    const F_TITLE  = 'Album Title';
    const F_ARTIST = 'Album Artist';
    const F_TRACK  = 'Track Name';
    const F_MP3    = 'mp3';
    const F_GENRE  = 'Local Genre';
    const F_LANG   = 'Language';

    // === Track sequence accessor (robust across common field names) ===
    function fTrackNo(f){
      const candidates = [
        f['Sequence Number'],
        f['Track Sequence'],
        f['Track No'],
        f['Track Number'],
        f['Track #'],
        f['Sequence'],
        f['Track_Index'],
        f['Track Order'],
        f['Index'],
        f['Song Sequence'],
        f['Song Number']
      ];
      for (const v of candidates){
        if (v !== undefined && v !== null && String(v).trim() !== ''){
          const n = Number(String(v).replace(/[^\d.-]/g,''));
          if (Number.isFinite(n)) return n;
        }
      }
      return null;
    }

    // Flexible field accessors to match your layout keys
    function fTitle(f){
      return f['Album Title'] || f['Tape Files::Album_Title'] || f['Album_Title'] || f['Title'] || '';
    }
    function fArtist(f){
      return f['Album Artist'] || f['Tape Files::Album Artist'] || f['Track Artist'] || f['Artist'] || '';
    }
    function fMp3(f){
      return f['mp3'] || f['MP3'] || f['Audio File'] || f['Audio::mp3'] || '';
    }
    function fLang(f){
      return f['Language'] || f['Language Code'] || '';
    }
    function hasValidMp3(s){
      return typeof s === 'string' && s.trim().length > 0;
    }

    function abortInFlight(){ if(inFlight){ inFlight.abort(); inFlight=null; } }

    // Show placeholder graphic from /img/* until user searches
    function showLanding(){
      lastQ = '';
      lastArtist = '';
      if (searchEl) searchEl.value = '';
      if (artistEl) artistEl.value = '';
      // Clear albums UI
      albumsEl.innerHTML = '';
      pagerEl.hidden = true;
      countEl.textContent = '';
      errorEl.hidden = true;
      currentEndpoint = '/api/search';
      currentParams = {};
      currentLimit = FM_FETCH_LIMIT;
      // Try a few common placeholder names; fall back to MAD_Logo.png
      const candidates = ['placeholder.png','placeholder.svg','landing.png','MAD_placeholder.png','MAD_Logo.png'];
      const img = document.createElement('img');
      let i = 0;
      function tryNext(){
        if(i >= candidates.length){ landingEl.innerHTML = ''; return; }
        img.src = '/img/' + candidates[i++];
      }
      img.alt = 'Placeholder';
      img.onerror = tryNext;
      landingEl.innerHTML = '';
      landingEl.appendChild(img);
      landingEl.style.display = 'flex';
      tryNext();
    }

    function hideLanding(){ landingEl.style.display = 'none'; }

    function fetchAlbums(endpoint, baseParams = {}, limitValue){
      abortInFlight();
      const ctrl = new AbortController();
      inFlight = ctrl;
      const params = new URLSearchParams();
      Object.entries(baseParams).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') {
          params.set(key, value);
        }
      });
      params.set('offset', '0');
      params.set('limit', String(limitValue));
      const queryString = params.toString();
      return fetch(`${endpoint}?${queryString}`, { signal: ctrl.signal })
        .then(async r => {
          if (!r.ok) throw new Error(await r.text().catch(() => `HTTP ${r.status}`));
          return r.json();
        })
        .finally(() => { if (inFlight === ctrl) inFlight = null; });
    }

    function doSearch(q){
      return fetchAlbums('/api/search', q ? { q } : {}, FM_FETCH_LIMIT);
    }


    // Strong normalization to reduce bogus “same album different title”
    function normTitle(s){
      return String(s||'')
        .replace(/\s+/g,' ')
        .replace(/[\u2018\u2019]/g,"'")
        .replace(/[\u201C\u201D]/g,'"')
        .replace(/^\W+|\W+$/g,'') // trim leading/trailing punctuation
        .trim();
    }
    function keyTitle(s){ return normTitle(s).toLowerCase(); }

    function groupAlbums(items){
      const byCat = new Map();

      for(const rec of items){
        const f = rec.fields || {};
        const cat = fCatalogue(f) || '__NO_CAT__';
        const title = normTitle(fTitle(f) || '(no album)');
        const artist= normTitle(fArtist(f) || '');
        const pic   = fPicture(f) || '';
        const track = normTitle(f[F_TRACK] || '');
        const mp3   = fMp3(f) || '';
        const genreRaw = f[F_GENRE] || f['Genre'] || '';
        const genre = normTitle(genreRaw || '');
        const producerRaw = f['Producer'] || '';
        const languageRaw = fLang(f) || '';
        const lang  = normTitle(languageRaw || '');
        const composer1 = f['Composer 1'] ?? f['Composer1'] ?? '';
        const composer2 = f['Composer 2'] ?? f['Composer2'] ?? '';
        const composer3 = f['Composer 3'] ?? f['Composer3'] ?? '';
        const composer4 = f['Composer 4'] ?? f['Composer4'] ?? '';
        const isrc = f['ISRC'] || '';
        const seq   = fTrackNo(f); // ← sequence number for ordering

        if(!byCat.has(cat)){
          byCat.set(cat, {
            catalogue: cat === '__NO_CAT__' ? '' : cat,
            titles: new Map(), // keyTitle -> {raw,count}
            artist, picture: pic || '',
            tracks: []
          });
        }
        const g = byCat.get(cat);

        const kt = keyTitle(title);
        const entry = g.titles.get(kt) || { raw: title, count: 0 };
        entry.count += 1; g.titles.set(kt, entry);

        if(!g.picture && pic) g.picture = pic;
        if(!g.artist && artist) g.artist = artist;

        // keep all tracks for title logic; mp3 validity filtered later
        if(track){
          g.tracks.push({
            name: track,
            mp3,
            seq,
            genre,
            genreDisplay: genreRaw,
            producer: producerRaw,
            language: lang,
            languageDisplay: languageRaw,
            composer1,
            composer2,
            composer3,
            composer4,
            isrc
          });
        }
      }

      const groups = [];
      for(const g of byCat.values()){
        // playable tracks only
        const playableTracks = g.tracks.filter(t => hasValidMp3(t.mp3));
        if (playableTracks.length === 0) {
          // Hide albums that do not have a valid mp3 file
          continue;
        }

        // Ignore title candidates that equal any track name (prevents “Sunday Afternoon” issue)
        const trackKeys = new Set(g.tracks.map(t => keyTitle(t.name)));
        const candidates = Array.from(g.titles.entries()); // [keyTitle, {raw,count}]
        const filtered = candidates.filter(([kt]) => !trackKeys.has(kt));

        const pickFrom = (arr) => arr.reduce((best, cur) => (!best || cur[1].count > best[1].count) ? cur : best, null);
        const pickedPair = pickFrom(filtered.length ? filtered : candidates);
        const displayTitle = pickedPair ? pickedPair[1].raw : '(no album)';

        // Sort playable tracks by sequence number when available; fallback to name
        playableTracks.sort((a,b)=>{
          const an = (typeof a.seq === 'number' && isFinite(a.seq)) ? a.seq : Infinity;
          const bn = (typeof b.seq === 'number' && isFinite(b.seq)) ? b.seq : Infinity;
          if (an !== bn) return an - bn;
          return a.name.localeCompare(b.name, undefined, { sensitivity:'base' });
        });

        groups.push({
          catalogue: g.catalogue,
          title: displayTitle,
          artist: g.artist,
          picture: g.picture,
          tracks: playableTracks
        });
      }

      groups.sort((a,b)=> a.title.localeCompare(b.title, undefined, { sensitivity:'base' }) || a.artist.localeCompare(b.artist, undefined, { sensitivity:'base' }));
      return groups;
    }

    /* ================= Track info modal ================= */
    function handleTrackInfoKeydown(e){
      if (!trackInfoOverlay.classList.contains('open')) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        closeTrackInfoModal();
        return;
      }
      if (e.key === 'Tab') {
        const focusables = trackInfoFocusables.filter(el => el && typeof el.focus === 'function' && !el.disabled && el.offsetParent !== null);
        if (focusables.length === 0) {
          e.preventDefault();
          return;
        }
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const active = document.activeElement;
        if (e.shiftKey) {
          if (active === first || !trackInfoOverlay.contains(active)) {
            e.preventDefault();
            last.focus();
          }
        } else {
          if (active === last) {
            e.preventDefault();
            first.focus();
          }
        }
      }
    }

    function openTrackInfoModal(track, trigger){
      if (!track) return;
      closeTrackInfoModal({ suppressFocus: true });
      trackInfoReturnFocus = trigger || null;
      const entries = [];
      const pushEntry = (label, value) => {
        if (value === undefined || value === null) return;
        const text = String(value).trim();
        if (text) entries.push({ label, value: text });
      };

      pushEntry('Producer', track.producer);
      pushEntry('Composer 1', track.composer1);
      pushEntry('Composer 2', track.composer2);
      pushEntry('Composer 3', track.composer3);
      pushEntry('Composer 4', track.composer4);
      pushEntry('Language', track.languageDisplay || track.language);
      pushEntry('Genre', track.genreDisplay || track.genre);
      pushEntry('ISRC', track.isrc);

      if (entries.length) {
        const dl = document.createElement('dl');
        entries.forEach(({ label, value }) => {
          const dt = document.createElement('dt'); dt.textContent = label;
          const dd = document.createElement('dd'); dd.textContent = value;
          dl.appendChild(dt); dl.appendChild(dd);
        });
        trackInfoBody.innerHTML = '';
        trackInfoBody.appendChild(dl);
      } else {
        trackInfoBody.innerHTML = '<p class="info-modal-empty">No additional metadata.</p>';
      }

      trackInfoOverlay.hidden = false;
      trackInfoOverlay.classList.add('open');
      trackInfoFocusables = Array.from(trackInfoDialog.querySelectorAll(trackInfoFocusableSelector));
      if (trackInfoFocusables.length === 0) {
        trackInfoDialog.setAttribute('tabindex', '-1');
        trackInfoFocusables = [trackInfoDialog];
      } else {
        trackInfoDialog.removeAttribute('tabindex');
      }
      const focusTarget = trackInfoFocusables[0] || trackInfoDialog;
      requestAnimationFrame(() => focusTarget.focus());
      document.addEventListener('keydown', handleTrackInfoKeydown, true);
    }

    function closeTrackInfoModal(options = {}){
      if (!trackInfoOverlay.classList.contains('open')) return;
      trackInfoOverlay.classList.remove('open');
      trackInfoOverlay.hidden = true;
      trackInfoBody.innerHTML = '';
      trackInfoDialog.removeAttribute('tabindex');
      document.removeEventListener('keydown', handleTrackInfoKeydown, true);
      const focusTarget = trackInfoReturnFocus;
      trackInfoReturnFocus = null;
      if (!options.suppressFocus && focusTarget && typeof focusTarget.focus === 'function') {
        requestAnimationFrame(() => focusTarget.focus());
      }
    }

    trackInfoOverlay.addEventListener('click', (e) => {
      if (e.target === trackInfoOverlay) {
        closeTrackInfoModal();
      }
    });
    trackInfoClose.addEventListener('click', () => closeTrackInfoModal());

    /* ================= Modal behavior ================= */
    function closeTracksModal(){
      closeTrackInfoModal({ suppressFocus: true });
      // stop playback when closing
      if (!player.paused) player.pause();
      updateButtonsForStop();
      currentSrc = '';
      overlay.classList.remove('open');
      overlay.setAttribute('aria-hidden', 'true');
      modalContent.innerHTML = '';
      modalCover.innerHTML = '';
      document.body.classList.remove('no-scroll');
    }

    function openTracksModal(album){
      // Ensure only one window open: close any existing
      closeTracksModal();

      // Fill header
      modalTitle.textContent = album.title || '(no album)';
      modalArtist.textContent = album.artist || '';
      modalCat.textContent = album.catalogue || '';
      if (!album.catalogue) modalCat.style.display = 'none'; else modalCat.style.display = 'inline-block';

      // Cover
      if (album.picture) {
        const wrap = document.createElement('div');
        wrap.className = 'cover-wrap';
        const img = document.createElement('img');
        img.src = `/api/container?u=${encodeURIComponent(album.picture)}`;
        img.alt = 'Cover';
        img.onerror = () => { modalCover.innerHTML = ''; };
        wrap.appendChild(img);
        modalCover.innerHTML = '';
        modalCover.appendChild(wrap);
        modalCover.style.display = 'block';
      } else {
        modalCover.innerHTML = '';
        modalCover.style.display = 'none';
      }

      // Build track list
      const ul = document.createElement('ul');
      ul.className = 'tracks';

      album.tracks.forEach((t, idx) => {
        const li = document.createElement('li');
        li.className = 'track';

        const top = document.createElement('div');
        top.className = 'track-top';

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = t.name || `Track ${idx+1}`;

        const controls = document.createElement('div');
        controls.className = 'controls';

        const btnPlay = document.createElement('button');
        btnPlay.className = 'btn small';
        btnPlay.textContent = 'Validating…';
        btnPlay.disabled = true;
        const src = t.mp3 ? (t.mp3.startsWith('http') ? `/api/container?u=${encodeURIComponent(t.mp3)}` : t.mp3) : '';
        li._src = src;
        li._btn = btnPlay;
        btnPlay.addEventListener('click', () => handlePlay(btnPlay, li, src));

        const btnMore = document.createElement('button');
        btnMore.className = 'btn small icon';
        btnMore.setAttribute('aria-label','More info');
        btnMore.textContent = '⋮';
        btnMore.addEventListener('click', () => openTrackInfoModal(t, btnMore));

        const invalidBadge = document.createElement('span');
        invalidBadge.className = 'badge badge-invalid';
        invalidBadge.textContent = 'Invalid audio';
        invalidBadge.hidden = true;

        controls.appendChild(btnPlay);
        controls.appendChild(btnMore);
        controls.appendChild(invalidBadge);

        top.appendChild(name);
        top.appendChild(controls);

        li.appendChild(top);

        // Progress UI (non-destructive)
        const progWrap = document.createElement('div');
        progWrap.className = 'progress';
        const seek = document.createElement('input');
        seek.type = 'range'; seek.className = 'seek'; seek.min = 0; seek.max = 100; seek.value = 0;
        const time = document.createElement('div');
        time.className = 'time'; time.textContent = '0:00 / 0:00';
        progWrap.appendChild(seek); progWrap.appendChild(time);
        li.appendChild(progWrap);
        li._seek = seek; li._time = time; li._seeking = false;
        // Seek while dragging (works while playing or paused)
        seek.addEventListener('input', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
        });
        seek.addEventListener('change', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
          li._seeking = false;
        });
        seek.addEventListener('pointerdown', () => { if (currentRow === li) li._seeking = true; });
        seek.addEventListener('pointerup',   () => { if (currentRow === li) li._seeking = false; });

        const markValid = (duration) => {
          li._valid = true;
          li._duration = duration;
          if (li._time) li._time.textContent = '0:00 / ' + fmtTime(duration);
          if (li._seek) li._seek.value = 0;
          btnPlay.disabled = false;
          btnPlay.textContent = '▶ Play';
          btnPlay.style.display = 'inline-flex';
          invalidBadge.hidden = true;
        };

        const markInvalid = () => {
          li._valid = false;
          li._duration = undefined;
          btnPlay.disabled = true;
          btnPlay.style.display = 'none';
          invalidBadge.hidden = false;
          if (li._time) li._time.textContent = 'Invalid audio';
        };

        if (src) {
          validateAudio(src).then(result => {
            if (!li.isConnected) return;
            if (result.ok) {
              markValid(result.duration);
            } else {
              markInvalid();
            }
          }).catch(() => {
            if (!li.isConnected) return;
            markInvalid();
          });
        } else {
          markInvalid();
        }

        ul.appendChild(li);
      });

      modalContent.innerHTML = '';
      modalContent.appendChild(ul);

      // Open
      overlay.classList.add('open');
      overlay.setAttribute('aria-hidden', 'false');
      document.body.classList.add('no-scroll');
    }

    modalClose.addEventListener('click', closeTracksModal);
    overlay.addEventListener('click', (e) => {
      // Close if clicking backdrop (but not clicks inside the dialog)
      if (e.target === overlay) closeTracksModal();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && overlay.classList.contains('open')) closeTracksModal();
    });

    /* ================= Rendering albums (cards) ================= */
    function renderAlbumPage(){
      albumsEl.innerHTML = '';
      const totalAlbums = albumGroups.length;
      if (totalAlbums) {
        countEl.textContent = `Albums: ${totalAlbums}`;
      } else if (lastQ) {
        countEl.textContent = 'No albums';
      } else if (lastArtist) {
        countEl.textContent = `No albums for "${lastArtist}"`;
      } else {
        countEl.textContent = '';
      }

      const maxPage = Math.max(1, Math.ceil(totalAlbums / ALBUMS_PER_PAGE));
      pagerEl.hidden = totalAlbums <= ALBUMS_PER_PAGE;
      albumPage = Math.min(albumPage, maxPage - 1);
      pageInfo.textContent = `Page ${albumPage+1} / ${maxPage}`;
      prevEl.disabled = albumPage <= 0;
      // next disabled only when we're at last page and there's nothing left to lazy-load
      nextEl.disabled = albumPage >= maxPage - 1 && rawItems.length >= rawTotalFound;

      const start = albumPage * ALBUMS_PER_PAGE;
      const end   = Math.min(start + ALBUMS_PER_PAGE, totalAlbums);
      const slice = albumGroups.slice(start, end);

      for (const album of slice) {
        const card = document.createElement('article');
        card.className = 'album-card';

        const coverButton = document.createElement('button');
        coverButton.type = 'button';
        coverButton.className = 'album-cover';
        coverButton.addEventListener('click', () => openTracksModal(album));
        coverButton.setAttribute('aria-label', album.title ? `Open tracks for ${album.title}` : 'Open tracks');

        if (album.picture) {
          coverButton.classList.remove('no-image');
          coverButton.textContent = '';
          const proxied = `/api/container?u=${encodeURIComponent(album.picture)}`;
          const img = document.createElement('img');
          img.src = proxied;
          img.alt = album.title ? `${album.title} cover` : 'Album cover';
          img.onerror = () => {
            coverButton.classList.add('no-image');
            coverButton.innerHTML = 'No cover';
          };
          coverButton.appendChild(img);
        } else {
          coverButton.classList.add('no-image');
          coverButton.textContent = 'No cover';
        }
        card.appendChild(coverButton);

        const body = document.createElement('div');
        body.className = 'album-body';

        const titleEl = document.createElement('h3');
        titleEl.className = 'album-title';
        titleEl.textContent = album.title || '(no album)';
        body.appendChild(titleEl);

        if (album.artist) {
          const subtitleEl = document.createElement('div');
          subtitleEl.className = 'subtitle';
          subtitleEl.textContent = album.artist;
          body.appendChild(subtitleEl);
        }

        const meta = document.createElement('div');
        meta.className = 'album-meta';
        if (album.catalogue) {
          const catBadge = document.createElement('span');
          catBadge.className = 'badge';
          catBadge.textContent = album.catalogue;
          meta.appendChild(catBadge);
        }
        if (meta.childElementCount) body.appendChild(meta);

        const actions = document.createElement('div');
        actions.className = 'album-actions';
        const showButton = document.createElement('button');
        showButton.type = 'button';
        showButton.className = 'btn small';
        showButton.textContent = `Show Tracks (${album.tracks.length})`;
        showButton.addEventListener('click', () => openTracksModal(album));
        actions.appendChild(showButton);
        body.appendChild(actions);

        card.appendChild(body);
        albumsEl.appendChild(card);
      }
    }

    /* ================= Playback ================= */
    function fmtTime(sec){ if(!isFinite(sec)||sec<0) sec=0; const m=Math.floor(sec/60); const s=Math.floor(sec%60); return m+':'+String(s).padStart(2,'0'); }

// --- Audio validator: preloads metadata, resolves with duration or failure
function validateAudio(url, timeoutMs = 5000) {
  return new Promise(resolve => {
    const audio = new Audio();
    audio.preload = 'metadata';
    audio.crossOrigin = 'anonymous';

    let settled = false;
    const cleanup = () => {
      audio.removeEventListener('loadedmetadata', onLoaded);
      audio.removeEventListener('error', onError);
      audio.removeEventListener('stalled', onError);
      audio.removeEventListener('abort', onError);
      try { audio.src = ''; } catch {}
      if (typeof audio.remove === 'function') {
        try { audio.remove(); } catch {}
      }
      clearTimeout(timer);
    };

    const finish = (result) => {
      if (settled) return;
      settled = true;
      cleanup();
      resolve(result);
    };

    const onLoaded = () => {
      const duration = audio.duration;
      if (Number.isFinite(duration) && duration > 0) {
        finish({ ok:true, duration });
      } else {
        finish({ ok:false, reason:'no-duration' });
      }
    };

    const onError = () => finish({ ok:false, reason:'error' });

    const timer = setTimeout(() => finish({ ok:false, reason:'timeout' }), timeoutMs);

    audio.addEventListener('loadedmetadata', onLoaded, { once:true });
    audio.addEventListener('error', onError, { once:true });
    audio.addEventListener('stalled', onError, { once:true });
    audio.addEventListener('abort', onError, { once:true });

    try {
      audio.src = url;
    } catch {
      finish({ ok:false, reason:'error' });
    }
  });
}
    function updateProgressUI(){
      if (!currentRow) return;
      const seek = currentRow._seek, time = currentRow._time;
      if (!seek || !time) return;
      const dur = player.duration, cur = player.currentTime;
      const pct = (dur && isFinite(dur)) ? Math.min(100, Math.max(0, (cur/dur)*100)) : 0;
      if (!(currentRow && currentRow._seeking)) { seek.value = String(pct); seek.style.setProperty('--fill', pct + '%'); }
      time.textContent = fmtTime(cur) + ' / ' + fmtTime(dur);
    }

    function handlePlay(btn, row, src){
      if (!src) return;
      if (currentSrc === src && !player.paused) { player.pause(); updateButtonsForStop(); return; }
      if (currentSrc !== src) { player.src = src; currentSrc = src; }
      player.play().then(() => {
        updateButtonsForStop();
        currentBtn = btn; currentRow = row; updateProgressUI();
        currentRow.classList.add('playing');
        currentBtn.textContent = '⏸ Pause';
        currentBtn.classList.add('btn-accent');
      }).catch(err => console.warn('Playback error:', err));
    }
    function updateButtonsForStop(){
      if (currentRow) currentRow.classList.remove('playing');
      if (currentBtn) { currentBtn.textContent = '▶ Play'; currentBtn.classList.remove('btn-accent'); }
      currentBtn = null; currentRow = null;
    }
    player.addEventListener('ended', () => {
      if (currentRow && currentRow.nextElementSibling && currentRow.nextElementSibling._src) {
        const nextLi = currentRow.nextElementSibling;
        handlePlay(nextLi._btn, nextLi, nextLi._src);
      } else {
        updateButtonsForStop(); currentSrc=''; updateProgressUI();
      }
    });
    player.addEventListener('timeupdate', () => { updateProgressUI(); });
    player.addEventListener('loadedmetadata', () => { updateProgressUI(); });
    player.addEventListener('pause', () => {
      if (currentBtn && currentSrc === player.src) {
        currentBtn.textContent = '▶ Play';
        currentBtn.classList.remove('btn-accent');
        if (currentRow) currentRow.classList.remove('playing');
      }
    });

    /* ================= Lazy-load FM rows ================= */
    async function loadMore(){
      showBusy('Searching…');
      try {
        if (rawItems.length >= rawTotalFound) return false; // nothing left
        const params = new URLSearchParams();
        Object.entries(currentParams).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            params.set(key, value);
          }
        });
        params.set('offset', String(rawNextOffset));
        params.set('limit', String(currentLimit));
        const r = await fetch(`${currentEndpoint}?${params.toString()}`);
        if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`));
        const j = await r.json();
        const newItems = j.items || [];
        rawItems = rawItems.concat(newItems);
        rawTotalFound = Number(j.total || rawTotalFound);
        const returnedOffset = Number(j.offset || 0);
        rawNextOffset = returnedOffset + newItems.length;
        albumGroups = groupAlbums(rawItems);
        return newItems.length > 0;
      } finally {
        hideBusy();
      }
    }
    /* ================= Search & paging ================= */
    async function runExplore(startYear){
      const start = Number(startYear) || 0;
      if (!start) return;
      lastQ = '';
      lastArtist = '';
      hideLanding();
      errorEl.hidden = true;
      errorEl.textContent = '';
      showBusy('Searching…');
      fetchAlbums('/api/explore', { decade: String(start) }, ALBUMS_PER_PAGE)
        .then(json => {
          rawItems = json?.items || [];
          rawTotalFound = Number(json?.total || rawItems.length);
          rawNextOffset = Number(json?.offset || 0) + rawItems.length;
          albumGroups = groupAlbums(rawItems);
          albumPage = 0;
          if (rawTotalFound === 0) {
            errorEl.hidden = false;
            errorEl.textContent = `No albums found for the ${start}s.`;
          }
          renderAlbumPage();
          currentEndpoint = '/api/explore';
          currentParams = { decade: String(start) };
          currentLimit = ALBUMS_PER_PAGE;
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          errorEl.hidden = false;
          errorEl.textContent = `Explore error: ${err.message || err}`;
        })
        .finally(() => hideBusy());
    }

    // Build decade chips and toggle
    if (decadesEl){
      const decades = [1950,1960,1970,1980,1990,2000,2010,2020];
      decadesEl.innerHTML = '';
      for(const d of decades){
        const b = document.createElement('button');
        b.textContent = d + 's';
        b.addEventListener('click', () => runExplore(d));
        decadesEl.appendChild(b);
      }
    }
    if (exploreEl){
      exploreEl.addEventListener('click', () => { decadesEl.hidden = !decadesEl.hidden; });
    }
/* ================= Search & paging ================= */
    function runArtist(term){
      const artist = term.trim();
      if (!artist) return;
      lastArtist = artist;
      lastQ = '';
      hideLanding();
      errorEl.hidden = true;
      errorEl.textContent = '';
      showBusy('Searching…');
      fetchAlbums('/api/search', { artist }, ARTIST_FETCH_LIMIT)
        .then(json => {
          rawItems = json?.items || [];
          rawTotalFound = Number(json?.total || rawItems.length);
          rawNextOffset = Number(json?.offset || 0) + rawItems.length;

          albumGroups = groupAlbums(rawItems);
          albumPage = 0;
          if (!rawItems.length) {
            errorEl.hidden = false;
            errorEl.textContent = `No albums found for "${artist}".`;
          }
          renderAlbumPage();

          currentEndpoint = '/api/search';
          currentParams = { artist };
          currentLimit = ARTIST_FETCH_LIMIT;
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          errorEl.hidden = false;
          errorEl.textContent = `Artist search error: ${err.message || err}`;
        })
        .finally(() => hideBusy());
    }

    function run(q){
      const query = q.trim();
      if(!query){ showLanding(); return; }
      lastQ = query;
      lastArtist = '';
      hideLanding();
      errorEl.hidden = true;
      errorEl.textContent = '';
      showBusy('Searching…');
      doSearch(query)
        .then(json => {
          rawItems = json?.items || [];
          rawTotalFound = Number(json?.total || rawItems.length);
          rawNextOffset = Number(json?.offset || 0) + rawItems.length;

          albumGroups = groupAlbums(rawItems);
          albumPage = 0;
          renderAlbumPage();

          currentEndpoint = '/api/search';
          currentParams = query ? { q: query } : {};
          currentLimit = FM_FETCH_LIMIT;
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          errorEl.hidden = false;
          errorEl.textContent = `Search error: ${err.message || err}`;
        })
        .finally(() => hideBusy());
    }
    goEl.addEventListener('click', () => {
      const artistTerm = artistEl.value.trim();
      if (artistTerm) { runArtist(artistTerm); return; }
      const q = searchEl.value.trim();
      run(q);
    });
    goArtistEl.addEventListener('click', () => runArtist(artistEl.value));
    searchEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const artistTerm = artistEl.value.trim();
        if (artistTerm) runArtist(artistTerm); else run(searchEl.value);
      }
    });
    searchEl.addEventListener('input', () => {
      clearTimeout(typingTimer);
      const q = searchEl.value.trim();
      if (artistEl.value.trim()) return;
      typingTimer = setTimeout(() => run(q), 300);
    });
    artistEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        runArtist(artistEl.value);
      }
    });
    clearEl.addEventListener('click', () => { searchEl.value=''; artistEl.value=''; showLanding(); });

    prevEl.addEventListener('click', () => {
      if (albumPage>0){ albumPage--; renderAlbumPage(); }
    });
    nextEl.addEventListener('click', async () => {
      const maxPage = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      // If at the last page but FM has more rows, fetch next chunk first
      if (albumPage >= maxPage - 1 && rawItems.length < rawTotalFound) {
        nextEl.disabled = true;
        try { await loadMore(); } finally { nextEl.disabled = false; }
      }
      const newMax = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      if (albumPage < newMax - 1) { albumPage++; renderAlbumPage(); }
      else { renderAlbumPage(); }
    });

    // Initial load — show placeholder image; search begins only after typing
    showLanding();
  </script>
</body>
</html>
