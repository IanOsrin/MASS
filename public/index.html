<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MASS — Albums & Tracks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#0f0f12; --fg:#f5f6f7; --muted:#a7abb3; --card:#17181c; --accent:#62f5a9; --border:#24262c;
      --cover-size: 140px; /* smaller, tidy covers */
      --overlay: rgba(0,0,0,.6);
      --btn-gradient-start:#3a7bd5;
      --btn-gradient-end:#00d2ff;
      --btn-text:#06121f;
      --btn-shadow:rgba(58,123,213,0.25);
      --btn-shadow-hover:rgba(58,123,213,0.35);
        }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;}
    header{padding:12px 18px;border-bottom:1px solid var(--border);position:sticky;top:0;background:linear-gradient(180deg,rgba(15,15,18,0.98),rgba(15,15,18,0.9));backdrop-filter:saturate(180%) blur(8px);z-index:10;}
    .header-main{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:18px;justify-content:space-between;flex-wrap:wrap;}
    .header-logo{flex-shrink:0;max-height:96px;filter:drop-shadow(0 6px 12px rgba(0,0,0,0.25));}
    .searchbar{flex:1;display:grid;grid-template-columns:minmax(0,1fr) auto auto;gap:8px;align-items:center;}
    .searchbar input{background:var(--card);color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:12px 14px;font-size:16px;outline:none;}
    .searchbar button{border-radius:10px;padding:12px 16px;font-weight:700;cursor:pointer;}

    main{max-width:1100px;margin:20px auto;padding:0 16px 40px;}
    .layout-grid{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap;}
    .playlist-column{flex:0 0 260px;max-width:260px;width:100%;display:flex;flex-direction:column;gap:14px;position:relative;order:2;}
    .playlist-column[hidden]{display:none !important;}
    .content-column{flex:1 1 560px;min-width:260px;display:flex;flex-direction:column;gap:16px;width:100%;order:1;}
    .playlist-actions{display:flex;align-items:center;gap:6px;}
    @media (max-width:900px){
      .layout-grid{flex-direction:column;}
      .playlist-column{max-width:100%;order:initial;}
      .content-column{order:initial;}
    }
    .albums{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:16px;}
    .albums.single-album{display:flex;flex-direction:column;align-items:center;gap:24px;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;display:flex;flex-direction:column;gap:10px;overflow:hidden;}
    .card.pending-audio{opacity:0.8;}
    .card.no-audio{border-color:#b9383a;box-shadow:0 0 0 1px rgba(185,56,58,0.45);}

    /* Cover: small, centered square; never bleeds */
    .cover-wrap{position:relative;width:var(--cover-size);height:var(--cover-size);border-radius:10px;overflow:hidden;border:1px solid var(--border);background:#101215;margin:0 auto;}
    .cover-wrap img{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;}
    .albums.single-album .cover-wrap{width:260px;height:260px;margin:0 auto 16px;}

    .heading{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:center;text-align:center;}
    .card h3{margin:0;font-size:18px;}
    .albums.single-album .card h3{font-size:26px;}
    .muted{color:var(--muted);font-size:13px;text-align:center;}
    .albums.single-album .muted{font-size:16px;}
    .badge{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:11px;color:var(--muted);}

    .btn{border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:600;}
    .btn.small{padding:6px 8px;font-size:13px;}
    .btn.icon{width:34px;display:inline-flex;align-items:center;justify-content:center;}
    .btn-accent{font-weight:700;filter:brightness(1.08);}
    .btn-error{background:#b9383a;border:none;color:#fff;box-shadow:0 6px 16px rgba(185,56,58,0.35);}
    .btn-error:hover{transform:none !important;box-shadow:0 6px 12px rgba(185,56,58,0.4) !important;}
    .btn-error:disabled{opacity:0.9;box-shadow:none;}
    .btn.info-more{font-size:18px;line-height:1;padding:4px 8px;display:flex;align-items:center;justify-content:center;}

    
    .back-row{display:flex;justify-content:center;margin-bottom:12px;}
.toolbar{display:flex;align-items:center;justify-content:space-between;margin:10px 0;}
    .pager{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:18px;}
    .pager button{border-radius:10px;padding:10px 12px;cursor:pointer;}
    .count{text-align:center;color:var(--muted);margin:6px 0 10px;font-size:14px;}
    .error{background:#2b1517;border:1px solid #5a2327;color:#ffb1b8;padding:10px 12px;border-radius:10px;}

    .explore-wrap{display:flex;align-items:center;gap:12px;flex-wrap:wrap;justify-content:flex-end;min-width:220px;}
    .decade-buttons{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end;max-width:380px;}
    .decade-buttons[hidden]{display:none;}
    .decade-buttons button{border-radius:999px;padding:6px 10px;cursor:pointer;font-size:13px;}
    #explore{padding:10px 20px;border-radius:14px;font-weight:700;font-size:15px;white-space:nowrap;}

    .auth-controls{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end;}
    .auth-controls .badge{font-size:12px;}
    .auth-controls [hidden]{display:none !important;}
    .auth-form{display:flex;flex-direction:column;gap:12px;margin-top:12px;}
    .auth-form label{display:flex;flex-direction:column;gap:6px;font-size:14px;}
    .auth-form input{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:var(--fg);}
    .auth-switch{display:flex;align-items:center;gap:6px;margin-top:12px;font-size:13px;color:var(--muted);}
    .auth-switch button{background:none;border:none;color:var(--accent);cursor:pointer;font-weight:600;padding:0;}
    .auth-switch button:disabled{opacity:.6;cursor:not-allowed;}
    #authError{margin-top:12px;}

    .playlists-panel{padding:12px;border:1px solid var(--border);border-radius:12px;background:var(--card);display:flex;flex-direction:column;gap:10px;}
    .playlists-panel[hidden]{display:none;}
    .playlists-header{display:flex;align-items:center;gap:12px;justify-content:space-between;}
    .playlists-header h2{margin:0;font-size:14px;letter-spacing:.02em;text-transform:uppercase;color:var(--muted);}
    .playlists-list{display:flex;flex-direction:column;gap:8px;}
    .playlist-pill{display:flex;flex-direction:column;align-items:flex-start;gap:2px;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:#1b1c20;color:#f5f5f5;cursor:pointer;min-width:0;transition:transform .15s ease,box-shadow .15s ease;font-size:12px;}
    .playlist-pill:hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(0,0,0,.25);}
    .playlist-pill.active{border-color:var(--accent);box-shadow:0 0 0 1px rgba(98,245,169,.4);}
    .playlist-pill .name{font-weight:600;font-size:13px;}
    .playlist-pill .meta{color:var(--muted);font-size:11px;}
    .playlist-empty{color:var(--muted);font-size:12px;}
    .playlist-create{display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
    .playlist-create input{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:8px 10px;color:var(--fg);flex:1;min-width:160px;font-size:13px;}
    .playlist-create button{padding:8px 12px;border-radius:8px;cursor:pointer;font-size:12px;}

    .playlist-tracks{padding:12px;border:1px solid var(--border);border-radius:12px;background:var(--card);display:flex;flex-direction:column;gap:10px;}
    .playlist-tracks[hidden]{display:none;}
    .playlist-tracks .playlists-header{margin-bottom:0;}
    .playlist-tracks .playlists-header h2{font-size:18px;}
    .playlist-tracks .muted{font-size:13px;}
    .playlist-tracks .tracks{display:flex;flex-direction:column;gap:8px;margin:0;padding:0;list-style:none;}
    .playlist-track{display:flex;gap:8px;padding:8px;border-radius:10px;background:#1d1f24;border:1px solid var(--border);align-items:flex-start;}
    .playlist-track.playing{outline:1px solid var(--accent);background:#202427;}
    .playlist-thumb{width:44px;height:44px;border-radius:8px;overflow:hidden;flex-shrink:0;background:#0e1014;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--muted);}
    .playlist-thumb img{width:100%;height:100%;object-fit:cover;display:block;}
    .playlist-track-content{display:flex;flex-direction:column;gap:6px;flex:1;min-width:0;}
    .playlist-track .track-top{display:flex;gap:8px;align-items:flex-start;}
    .playlist-track .play-control{display:flex;align-items:center;margin-right:6px;}
    .playlist-track .play-control .btn.small{padding:5px 8px;font-size:11px;}
    .playlist-track .play-control{display:flex;align-items:center;margin-right:4px;}
    .playlist-track .play-control .btn.small{padding:5px 8px;font-size:11px;}
    .playlist-track .track-title{flex:1;min-width:0;display:flex;flex-direction:column;gap:2px;}
    .playlist-track .track-title .name{font-weight:600;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .playlist-track .track-title .artist{color:var(--muted);font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .playlist-track .btn.small{padding:5px 8px;font-size:11px;}
    .playlist-track .progress{margin-top:2px;}
    .playlist-track .progress .seek{width:150px;}
    .playlist-track .progress .time{font-size:11px;}
    .playlist-track-meta-buttons{display:flex;gap:4px;flex-wrap:wrap;margin-top:4px;}
    .playlist-track-meta-buttons .btn.small{padding:4px 6px;font-size:10px;}
    .playlist-tracks.collapsed .tracks{display:none;}
    .playlist-tracks.collapsed .playlist-empty{display:none;}
    .playlist-tracks.only-current .tracks{display:none;}
    .playlist-tracks.only-current .playlist-empty{display:none;}
    .playlist-tracks.only-current .now-playing-placeholder{display:none;}

    .now-playing{padding:12px;border:1px solid var(--border);border-radius:12px;background:#1d1f24;display:flex;flex-direction:column;gap:10px;}
    .now-playing[hidden]{display:none !important;}
    .now-playing-header{display:flex;align-items:center;justify-content:space-between;gap:8px;}
    .now-playing-header .label{font-size:12px;font-weight:600;letter-spacing:.04em;text-transform:uppercase;color:var(--muted);}
    .now-playing-body{display:flex;align-items:center;gap:10px;}
    .now-playing-thumb{width:44px;height:44px;border-radius:8px;overflow:hidden;flex-shrink:0;background:#0e1014;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--muted);}
    .now-playing-thumb img{width:100%;height:100%;object-fit:cover;display:block;}
    .now-playing-meta{display:flex;flex-direction:column;gap:2px;min-width:0;}
    .now-playing-title{font-size:13px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .now-playing-sub{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .now-playing-source{font-size:11px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .now-playing-controls{display:flex;align-items:center;gap:8px;}
    .now-playing-meta-buttons{display:flex;flex-direction:column;align-items:flex-start;gap:4px;}
    .now-playing-meta-buttons .btn.small{padding:5px 8px;font-size:11px;}
    .now-playing-meta-list{display:flex;flex-direction:column;gap:3px;font-size:12px;margin-top:2px;}
    .now-playing-meta-line{color:#dcdcdc;line-height:1.3;}
    .now-playing-meta-line strong{color:#fff;font-weight:600;margin-right:4px;}
    .now-playing-status{font-size:11px;color:var(--muted);}
    .now-playing-progress{width:100%;height:6px;background:#262830;border-radius:4px;overflow:hidden;position:relative;margin-top:6px;}
    .now-playing-progress .fill{position:absolute;inset:0;background:linear-gradient(90deg,var(--accent),#6bd3ff);width:0%;border-radius:4px;transition:width .1s linear;}
    .now-playing-controls .btn.small{padding:6px 10px;font-size:12px;}
    .now-playing.collapsed .now-playing-body,
    .now-playing.collapsed .now-playing-controls{display:none;}

    /* Landing placeholder */
    .landing{display:flex;align-items:center;justify-content:center;min-height:40vh;}
    .landing img{max-width:520px;max-height:520px;opacity:.9;display:block;}

    /* ======= Modal (centered track window) ======= */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:var(--overlay);z-index:100;}
    .overlay.open{display:flex;}
    .modal{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.35);width:min(900px,94vw);max-height:88vh;display:flex;flex-direction:column;overflow:hidden;}
    .modal header{display:flex;align-items:center;gap:12px;padding:12px 14px;border-bottom:1px solid var(--border);background:#14161a;position:sticky;top:0;z-index:1;}
    .modal .cover-wrap{width:56px;height:56px;margin:0;}
    .modal .meta{display:flex;flex-direction:column;gap:2px;min-width:0;}
    .modal h2{margin:0;font-size:18px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .modal .sub{color:var(--muted);font-size:13px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .modal .spacer{flex:1;}
    .modal .close{border-radius:10px;padding:8px 10px;cursor:pointer;}
    .modal .content{padding:12px;overflow:auto;}
    .tracks{margin:0;padding:0;list-style:none;display:flex;flex-direction:column;gap:8px;}
    .track{background:#1f1f23;padding:8px 10px;border-radius:8px;display:flex;flex-direction:column;gap:6px;}
    .track.loading{opacity:0.75;}
    .track.loading .btn.small{pointer-events:none;}
    .track-top{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .track-title{display:flex;flex-direction:column;flex:1;min-width:0;}
    .track .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .track .artist{color:var(--muted);font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .controls{display:flex;align-items:center;gap:6px;}
    .playing{outline:1px solid var(--accent); background:#202427;}
    .progress{display:flex;align-items:center;gap:8px;margin-top:6px;}
    .seek{appearance:none;width:240px;height:8px;background:linear-gradient(var(--accent),var(--accent)) 0/var(--fill,0%) 100% no-repeat,#1b2a21;border-radius:999px;outline:none;border:1px solid var(--accent);}
    .seek::-webkit-slider-thumb{appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);}
    .time{font-size:12px;color:var(--muted);min-width:98px;text-align:right;}
    .no-scroll{overflow:hidden;}

    .info-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:150;}
    .info-modal-overlay.open{display:flex;}
    .info-modal{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px 20px;width:min(480px,92vw);max-height:80vh;overflow:auto;box-shadow:0 18px 48px rgba(0,0,0,.4);}
    .info-modal header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px;}
    .info-modal h3{margin:0;font-size:18px;}
    .info-modal .info-close{border-radius:8px;padding:6px 10px;cursor:pointer;}
    .info-modal dl{margin:0;display:grid;grid-template-columns:minmax(120px,auto) 1fr;gap:10px 14px;font-size:14px;}
    .info-modal dt{font-weight:600;color:var(--muted);}
    .info-modal dd{margin:0;}
    .info-modal-empty{color:var(--muted);font-style:italic;text-align:center;margin:12px 0;}

    /* Busy / searching status indicator */
    .status{display:inline-flex;align-items:center;gap:8px;margin-left:8px;color:var(--muted);font-size:13px;}
    .status[hidden]{display:none;}
    .status .pulse{width:8px;height:8px;border-radius:50%;background:var(--accent);
      box-shadow:0 0 0 0 rgba(98,245,169,.7);animation:pulse 1.3s infinite;}
    @keyframes pulse{
      0%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,.7);}
      70%{transform:scale(1);box-shadow:0 0 0 10px rgba(98,245,169,0);}
      100%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,0);}
        }
    .btn,
    .searchbar button,
    .pager button,
    .decade-buttons button,
    .modal .close,
    .info-modal .info-close,
    #explore {
      background:linear-gradient(135deg,var(--btn-gradient-start),var(--btn-gradient-end));
      color:var(--btn-text);
      border:none;
      box-shadow:0 6px 18px var(--btn-shadow);
      transition:transform 0.15s ease,box-shadow 0.15s ease,opacity 0.15s ease;
    }

    .btn:hover,
    .searchbar button:hover,
    .pager button:hover,
    .decade-buttons button:hover,
    .modal .close:hover,
    .info-modal .info-close:hover,
    #explore:hover {
      transform:translateY(-1px);
      box-shadow:0 8px 20px var(--btn-shadow-hover);
    }

    .btn:active,
    .searchbar button:active,
    .pager button:active,
    .decade-buttons button:active,
    .modal .close:active,
    .info-modal .info-close:active,
    #explore:active {
      transform:translateY(0);
      box-shadow:0 5px 14px var(--btn-shadow);
    }

    button:disabled{opacity:.6;cursor:not-allowed;transform:none !important;box-shadow:none !important;}

  </style>
</head>
<body>
  <header>
    <div class="header-main">
      <img src="/img/MAD_Logo.png" alt="MAD Logo" class="header-logo">
      <div class="searchbar">
        <input id="search" type="search" placeholder="Search albums, artists, tracks, year, genre…" autocomplete="off" />
        <button id="go">Search</button>
        <button id="clear">Clear</button>
        <span id="status" class="status" hidden aria-live="polite" role="status"><span class="pulse"></span><span id="statusText">Searching…</span></span>
      </div>
      <div class="explore-wrap">
        <button id="explore" type="button" aria-expanded="false">Explore</button>
        <div id="decadeButtons" class="decade-buttons" hidden></div>
        <div id="authControls" class="auth-controls">
          <span id="userBadge" class="badge" hidden></span>
          <button id="loginTrigger" type="button" class="btn small">Log in</button>
          <button id="signupTrigger" type="button" class="btn small">Sign up</button>
          <button id="logoutButton" type="button" class="btn small" hidden>Log out</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="layout-grid">
      <aside id="playlistColumn" class="playlist-column" hidden>
        <section id="playlistsPanel" class="playlists-panel" hidden>
          <div class="playlists-header">
            <h2>My Playlists</h2>
            <span id="playlistsStatus" class="muted"></span>
          </div>
          <div id="playlistsList" class="playlists-list"></div>
          <form id="playlistCreateForm" class="playlist-create" autocomplete="off">
            <input id="playlistNameInput" type="text" placeholder="Create new playlist" maxlength="80" />
            <button type="submit" class="btn small">Create</button>
          </form>
          <div id="playlistsEmpty" class="playlist-empty" hidden>No playlists yet. Create one to start saving tracks.</div>
        </section>
        <section id="nowPlayingCard" class="now-playing" hidden>
          <div class="now-playing-header">
            <span class="label">Now Playing</span>
            <button id="nowPlayingCollapse" type="button" class="btn small">Hide info</button>
          </div>
          <div class="now-playing-body">
            <div id="nowPlayingThumb" class="now-playing-thumb">--</div>
            <div class="now-playing-meta">
              <div id="nowPlayingTitle" class="now-playing-title">Track</div>
              <div id="nowPlayingSubtitle" class="now-playing-sub">Artist</div>
              <div id="nowPlayingSource" class="now-playing-source"></div>
            </div>
          </div>
          <div class="now-playing-controls">
            <span id="nowPlayingStatus" class="now-playing-status">Paused</span>
            <div id="nowPlayingMetaButtons" class="now-playing-meta-buttons"></div>
            <button id="nowPlayingToggle" type="button" class="btn small">Play</button>
          </div>
          <div class="now-playing-progress">
            <div id="nowPlayingProgressFill" class="fill"></div>
          </div>
        </section>
        <section id="playlistTracksSection" class="playlist-tracks" hidden>
          <div class="playlists-header">
            <h2 id="playlistTracksTitle">Playlist</h2>
            <div class="playlist-actions">
              <button id="togglePlaylistTracks" type="button" class="btn small">Hide tracks</button>
              <button id="deletePlaylistButton" type="button" class="btn small btn-error">Delete playlist</button>
            </div>
          </div>
          <div id="playlistTracksMeta" class="muted"></div>
          <ul id="playlistTracksList" class="tracks"></ul>
          <div id="playlistTracksEmpty" class="playlist-empty" hidden>No tracks in this playlist yet.</div>
        </section>
      </aside>
      <section class="content-column">
        <div id="landing" class="landing" aria-hidden="false"></div>
        <div class="toolbar">
          <div id="count" class="count"></div>
        </div>
        <div id="albums" class="albums"></div>
        <div id="pager" class="pager" hidden>
          <button id="prev">◀ Prev</button>
          <span id="pageInfo" class="badge">Page 1</span>
          <button id="next">Next ▶</button>
        </div>
        <div id="error" class="error" hidden></div>
      </section>
    </div>
  </main>

  <!-- Single centered modal (reused for all albums) -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <div id="modalCover" class="cover-wrap" aria-hidden="true"></div>
        <div class="meta">
          <h2 id="modalTitle">Album</h2>
          <div class="sub">
            <span id="modalArtist"></span>
            <span id="modalCat" class="badge"></span>
          </div>
        </div>
        <div class="spacer"></div>
        <button id="modalClose" class="close" aria-label="Close">✕</button>
          </header>
      <div id="modalContent" class="content"></div>
    </div>
  </div>

  <div id="trackInfoOverlay" class="info-modal-overlay" hidden>
    <div id="trackInfoDialog" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="trackInfoTitle">
      <header>
        <h3 id="trackInfoTitle">More info</h3>
        <button type="button" id="trackInfoClose" class="info-close">Close</button>
      </header>
      <div id="trackInfoBody"></div>
    </div>
  </div>

  <div id="authOverlay" class="info-modal-overlay" hidden>
    <div id="authDialog" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <header>
        <h3 id="authTitle">Log in</h3>
        <button type="button" id="authClose" class="info-close">Close</button>
      </header>
      <form id="authForm" class="auth-form">
        <label for="authEmail">
          <span>Email</span>
          <input id="authEmail" type="email" name="email" autocomplete="email" required />
        </label>
        <label for="authPassword">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="8" required />
        </label>
        <button type="submit" id="authSubmit" class="btn btn-accent">Log in</button>
      </form>
      <div class="auth-switch">
        <span id="authToggleText">Need an account?</span>
        <button type="button" id="authSwitchMode">Sign up</button>
      </div>
      <div id="authError" class="error" hidden></div>
    </div>
  </div>

  <audio id="player" preload="none"></audio>

  <script>
    const albumsEl = document.getElementById('albums');
    const searchEl = document.getElementById('search');
    const clearEl  = document.getElementById('clear');
    const goEl  = document.getElementById('go');
    const pagerEl  = document.getElementById('pager');
    const prevEl   = document.getElementById('prev');
    const nextEl   = document.getElementById('next');
    const pageInfo = document.getElementById('pageInfo');
    const countEl  = document.getElementById('count');
    const errorEl  = document.getElementById('error');
    const player   = document.getElementById('player');
    const landingEl = document.getElementById('landing');
    const exploreEl = document.getElementById('explore');
    const decadeButtonsEl = document.getElementById('decadeButtons');

    // Modal elements
    const overlay = document.getElementById('overlay');
    const modalCover = document.getElementById('modalCover');
    const modalTitle = document.getElementById('modalTitle');
    const modalArtist = document.getElementById('modalArtist');
    const modalCat = document.getElementById('modalCat');
    const modalContent = document.getElementById('modalContent');
    const modalClose = document.getElementById('modalClose');
    const trackInfoOverlay = document.getElementById('trackInfoOverlay');
    const trackInfoDialog = document.getElementById('trackInfoDialog');
    const trackInfoBody = document.getElementById('trackInfoBody');
    const trackInfoClose = document.getElementById('trackInfoClose');

    const playlistColumn = document.getElementById('playlistColumn');
    const playlistsPanel = document.getElementById('playlistsPanel');
    const playlistsList = document.getElementById('playlistsList');
    const playlistsStatus = document.getElementById('playlistsStatus');
    const playlistsEmpty = document.getElementById('playlistsEmpty');
    const playlistCreateForm = document.getElementById('playlistCreateForm');
    const playlistNameInput = document.getElementById('playlistNameInput');
    const nowPlayingCard = document.getElementById('nowPlayingCard');
    const nowPlayingThumb = document.getElementById('nowPlayingThumb');
    const nowPlayingTitle = document.getElementById('nowPlayingTitle');
    const nowPlayingSubtitle = document.getElementById('nowPlayingSubtitle');
    const nowPlayingSource = document.getElementById('nowPlayingSource');
    const nowPlayingStatus = document.getElementById('nowPlayingStatus');
    const nowPlayingMetaButtons = document.getElementById('nowPlayingMetaButtons');
    const nowPlayingToggleButton = document.getElementById('nowPlayingToggle');
    const nowPlayingCollapseButton = document.getElementById('nowPlayingCollapse');
    const nowPlayingProgressFill = document.getElementById('nowPlayingProgressFill');
    const playlistTracksSection = document.getElementById('playlistTracksSection');
    const playlistTracksTitle = document.getElementById('playlistTracksTitle');
    const playlistTracksMeta = document.getElementById('playlistTracksMeta');
    const playlistTracksList = document.getElementById('playlistTracksList');
    const playlistTracksEmpty = document.getElementById('playlistTracksEmpty');
    const togglePlaylistTracksButton = document.getElementById('togglePlaylistTracks');
    const deletePlaylistButton = document.getElementById('deletePlaylistButton');

    const authControls = document.getElementById('authControls');
    const loginTrigger = document.getElementById('loginTrigger');
    const signupTrigger = document.getElementById('signupTrigger');
    const logoutButton = document.getElementById('logoutButton');
    const userBadge = document.getElementById('userBadge');
    const authOverlay = document.getElementById('authOverlay');
    const authDialog = document.getElementById('authDialog');
    const authClose = document.getElementById('authClose');
    const authForm = document.getElementById('authForm');
    const authTitle = document.getElementById('authTitle');
    const authEmail = document.getElementById('authEmail');
    const authPassword = document.getElementById('authPassword');
    const authSubmit = document.getElementById('authSubmit');
    const authSwitch = document.getElementById('authSwitchMode');
    const authToggleText = document.getElementById('authToggleText');
    const authError = document.getElementById('authError');

    const trackInfoFocusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    let trackInfoReturnFocus = null;
    let trackInfoFocusables = [];

    let authReturnFocus = null;
    let authMode = 'login';
    let authBusy = false;
    let currentUser = null;
    let playlists = [];
    let playlistsLoaded = false;
    let playlistsLoading = false;
    let activePlaylistId = null;
    let playlistTracksCollapsed = false;
    let nowPlayingInfo = { meta: null, isPlaying: false };
    let nowPlayingCollapsed = false;

    // Config
    const ALBUMS_PER_PAGE = 9;
    const FM_FETCH_LIMIT  = 200; // UI asks for 200; FM may cap ~100 internally

    // State
    let lastQ = '';
    let prevSearch = null;
    let inFlight = null;

    // Busy status indicator
    const statusEl = document.getElementById('status');
    const statusTextEl = document.getElementById('statusText');
    let busyCount = 0;
    function showBusy(label='Searching…'){
      busyCount++;
      if (statusTextEl) statusTextEl.textContent = label;
      if (statusEl) statusEl.hidden = false;
      if (goEl) goEl.disabled = true;
      if (exploreEl) exploreEl.disabled = true;
        }
    function hideBusy(){
      busyCount = Math.max(0, busyCount - 1);
      if (busyCount === 0){
        if (statusEl) statusEl.hidden = true;
        if (goEl) goEl.disabled = false;
        if (exploreEl) exploreEl.disabled = false;
      }
        }

    function clearAuthError(){
      if (!authError) return;
      authError.hidden = true;
      authError.textContent = '';
    }

    function setAuthError(message){
      if (!authError) return;
      if (!message) {
        clearAuthError();
        return;
      }
      authError.hidden = false;
      authError.textContent = message;
    }

    function setAuthMode(mode){
      authMode = mode === 'register' ? 'register' : 'login';
      if (authTitle) authTitle.textContent = authMode === 'register' ? 'Create account' : 'Log in';
      if (authSubmit) {
        const base = authMode === 'register' ? 'Sign up' : 'Log in';
        authSubmit.textContent = authBusy
          ? (authMode === 'register' ? 'Creating…' : 'Signing in…')
          : base;
      }
      if (authToggleText) authToggleText.textContent = authMode === 'register' ? 'Already have an account?' : 'Need an account?';
      if (authSwitch) authSwitch.textContent = authMode === 'register' ? 'Log in' : 'Sign up';
      if (authPassword) authPassword.setAttribute('autocomplete', authMode === 'register' ? 'new-password' : 'current-password');
    }

    function setAuthBusy(isBusy){
      authBusy = !!isBusy;
      if (authSubmit) {
        authSubmit.disabled = authBusy;
        const base = authMode === 'register' ? 'Sign up' : 'Log in';
        authSubmit.textContent = authBusy
          ? (authMode === 'register' ? 'Creating…' : 'Signing in…')
          : base;
      }
      if (authSwitch) authSwitch.disabled = authBusy;
      if (authClose) authClose.disabled = authBusy;
      updateAuthUI();
    }

    function updateAuthUI(){
      const email = currentUser?.email || '';
      if (userBadge) {
        if (email) {
          userBadge.textContent = email;
          userBadge.hidden = false;
        } else {
          userBadge.hidden = true;
          userBadge.textContent = '';
        }
      }
      if (logoutButton) {
        logoutButton.hidden = !email;
        logoutButton.disabled = authBusy;
      }
      if (loginTrigger) {
        loginTrigger.hidden = !!email;
        loginTrigger.disabled = authBusy && !email;
      }
      if (signupTrigger) {
        signupTrigger.hidden = !!email;
        signupTrigger.disabled = authBusy && !email;
      }
      if (authControls) {
        authControls.hidden = false;
      }
      if (playlistColumn) playlistColumn.hidden = !currentUser;
      if (playlistsPanel && playlistColumn && !playlistColumn.hidden) playlistsPanel.hidden = false;
      renderPlaylistsPanel();
    }

    function getMetaFromRow(row){
      if (!row) return null;
      const base = row._meta ? { ...row._meta } : null;
      if (!base) return null;
      if (base.playlistId && !base.playlistName) {
        const pl = playlists.find((p) => p && p.id === base.playlistId);
        if (pl) base.playlistName = pl.name || '';
      }
      base.src = row._src || '';
      return base;
    }

    function updateNowPlayingUI(){
      if (!nowPlayingCard) return;
      const meta = nowPlayingInfo.meta;
      if (!meta) {
        if (nowPlayingProgressFill) nowPlayingProgressFill.style.width = '0%';
        if (nowPlayingMetaButtons) nowPlayingMetaButtons.innerHTML = '';
        nowPlayingCard.hidden = true;
        return;
      }

      nowPlayingCard.hidden = false;
      nowPlayingCard.classList.toggle('collapsed', nowPlayingCollapsed);

      if (nowPlayingTitle) nowPlayingTitle.textContent = meta.trackName || 'Track';
      if (nowPlayingSubtitle) nowPlayingSubtitle.textContent = meta.trackArtist || meta.albumArtist || '';

      if (nowPlayingSource) {
        const parts = [];
        if (meta.playlistName) parts.push(`Playlist • ${meta.playlistName}`);
        if (meta.albumTitle) parts.push(meta.playlistName ? `Album • ${meta.albumTitle}` : meta.albumTitle);
        if (meta.catalogue) parts.push(`#${meta.catalogue}`);
        nowPlayingSource.textContent = parts.join(' • ');
      }

      if (nowPlayingMetaButtons) {
        nowPlayingMetaButtons.innerHTML = '';
        const infoButton = document.createElement('button');
        infoButton.type = 'button';
        infoButton.className = 'btn small info-more';
        infoButton.setAttribute('aria-label', 'More track info');
        infoButton.innerHTML = '<span aria-hidden="true">⋮</span>';
        infoButton.addEventListener('click', () => openTrackInfoModal(meta, infoButton));
        nowPlayingMetaButtons.appendChild(infoButton);

        const details = collectTrackMetadata(meta);
        if (details.length) {
          const list = document.createElement('div');
          list.className = 'now-playing-meta-list';
          details.forEach(({ label, value }) => {
            const line = document.createElement('div');
            line.className = 'now-playing-meta-line';
            const key = document.createElement('strong');
            key.textContent = `${label}:`;
            line.appendChild(key);
            line.appendChild(document.createTextNode(` ${value}`));
            list.appendChild(line);
          });
          nowPlayingMetaButtons.appendChild(list);
        }
      }

      if (nowPlayingStatus) nowPlayingStatus.textContent = nowPlayingInfo.isPlaying ? 'Playing' : 'Paused';

      if (nowPlayingToggleButton) {
        nowPlayingToggleButton.textContent = nowPlayingInfo.isPlaying ? 'Pause' : 'Play';
        nowPlayingToggleButton.disabled = !meta.src;
      }

      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = '0%';
      }

      if (nowPlayingCollapseButton) {
        nowPlayingCollapseButton.textContent = nowPlayingCollapsed ? 'Show info' : 'Hide info';
      }

      if (nowPlayingThumb) {
        nowPlayingThumb.innerHTML = '';
        if (meta.picture) {
          const raw = String(meta.picture || '');
          const artSrc = raw.startsWith('/api/container?') || /^https?:/i.test(raw)
            ? raw
            : `/api/container?u=${encodeURIComponent(raw)}`;
          const img = document.createElement('img');
          img.src = artSrc;
          img.alt = 'Artwork';
          img.onerror = () => { nowPlayingThumb.innerHTML = 'No art'; };
          nowPlayingThumb.appendChild(img);
        } else {
          nowPlayingThumb.textContent = 'No art';
        }
      }
    }

    function setNowPlayingFromRow(row, isPlaying){
      const meta = getMetaFromRow(row);
      if (!meta) {
        nowPlayingInfo.meta = null;
        nowPlayingInfo.isPlaying = false;
      } else {
        if (!nowPlayingInfo.meta) nowPlayingCollapsed = false;
        nowPlayingInfo.meta = meta;
        nowPlayingInfo.isPlaying = !!isPlaying;
      }
      updateNowPlayingUI();
      syncPlaylistOnlyCurrent();
    }

    function markNowPlayingInactive(){
      if (nowPlayingInfo.meta) {
        nowPlayingInfo.isPlaying = false;
        updateNowPlayingUI();
        syncPlaylistOnlyCurrent();
      }
    }

    function clearNowPlaying(){
      nowPlayingInfo.meta = null;
      nowPlayingInfo.isPlaying = false;
      nowPlayingCollapsed = false;
      updateNowPlayingUI();
      syncPlaylistOnlyCurrent();
    }

    function syncPlaylistOnlyCurrent(){
      if (!playlistTracksSection) return;
      const should = Boolean(nowPlayingInfo.meta && nowPlayingInfo.isPlaying && nowPlayingInfo.meta.playlistId === activePlaylistId);
      playlistTracksSection.classList.toggle('only-current', should);
    }

    function clearPlaylists(){
      playlists = [];
      playlistsLoaded = false;
      playlistsLoading = false;
      activePlaylistId = null;
      playlistTracksCollapsed = false;
      clearNowPlaying();
      renderPlaylistsPanel();
    }

    async function loadUserPlaylists(){
      if (!currentUser) {
        clearPlaylists();
        return [];
      }
      if (playlistsLoading) return playlists;
      playlistsLoading = true;
      try {
        const res = await fetch('/api/playlists', { headers: { 'Accept': 'application/json' } });
        if (res.status === 401) {
          currentUser = null;
          clearPlaylists();
          updateAuthUI();
          return [];
        }
        if (!res.ok) throw new Error('Failed to load playlists');
        const json = await res.json().catch(() => ({}));
        playlists = Array.isArray(json?.playlists) ? json.playlists : [];
        playlistsLoaded = true;
        if (!playlists.length) {
          activePlaylistId = null;
        } else if (!activePlaylistId || !playlists.some((p) => p && p.id === activePlaylistId)) {
          activePlaylistId = playlists[0]?.id || null;
        }
        playlistTracksCollapsed = false;
        renderPlaylistsPanel();
        return playlists;
      } catch (err) {
        console.warn('Playlist fetch failed:', err);
        playlistsLoaded = false;
        renderPlaylistsPanel();
        return [];
      } finally {
        playlistsLoading = false;
        renderPlaylistsPanel();
      }
    }

    async function ensurePlaylistsLoaded(){
      if (!playlistsLoaded) {
        await loadUserPlaylists();
      } else {
        renderPlaylistsPanel();
      }
      return playlists;
    }

    async function createPlaylistOnServer(name){
      const trimmed = typeof name === 'string' ? name.trim() : '';
      if (!trimmed) throw new Error('Playlist name required');
      const res = await fetch('/api/playlists', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ name: trimmed })
      });
      const json = await res.json().catch(() => ({}));
      if (res.status === 409 && json?.playlist) {
        playlists = Array.isArray(playlists) ? playlists : [];
        const existing = json.playlist;
        const idx = playlists.findIndex((p) => p && p.id === existing.id);
        if (idx === -1) playlists.push(existing);
        playlistsLoaded = true;
        activePlaylistId = existing?.id || activePlaylistId;
        renderPlaylistsPanel();
        return existing;
      }
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || 'Failed to create playlist');
      }
      const playlist = json.playlist;
      playlists = Array.isArray(playlists) ? playlists.slice() : [];
      playlists.push(playlist);
      playlistsLoaded = true;
      activePlaylistId = playlist?.id || activePlaylistId;
      renderPlaylistsPanel();
      return playlist;
    }

    async function addTrackToPlaylistOnServer(playlistId, trackPayload){
      const res = await fetch(`/api/playlists/${encodeURIComponent(playlistId)}/tracks`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ track: trackPayload })
      });
      const json = await res.json().catch(() => ({}));
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || 'Failed to add track to playlist');
      }
      const updated = json.playlist;
      const track = json.track;
      const idx = playlists.findIndex((p) => p && p.id === updated?.id);
      if (idx !== -1) {
        playlists[idx] = updated;
      } else if (updated) {
        playlists.push(updated);
      }
      playlistsLoaded = true;
      activePlaylistId = updated?.id || activePlaylistId;
      renderPlaylistsPanel();
      return { playlist: updated, track, duplicate: json.duplicate }; // duplicate flag optional
    }

    function getActivePlaylist(){
      if (!activePlaylistId) return null;
      return playlists.find((p) => p && p.id === activePlaylistId) || null;
    }

    function setActivePlaylist(id){
      if (!id || !playlists.some((p) => p && p.id === id)) {
        activePlaylistId = null;
        playlistTracksCollapsed = false;
      } else {
        if (activePlaylistId !== id) playlistTracksCollapsed = false;
        activePlaylistId = id;
      }
      renderPlaylistsPanel();
    }

    function renderPlaylistsPanel(){
      if (!playlistsPanel) return;
      const hasUser = Boolean(currentUser);
      const list = Array.isArray(playlists) ? playlists.filter(Boolean) : [];

      if (playlistColumn) playlistColumn.hidden = !hasUser;

      if (!hasUser) {
        playlistsPanel.hidden = true;
        renderPlaylistTracks();
        return;
      }

      playlistsPanel.hidden = false;

      if (playlistsStatus) {
        if (playlistsLoading) playlistsStatus.textContent = 'Loading…';
        else playlistsStatus.textContent = list.length ? `${list.length} playlist${list.length === 1 ? '' : 's'}` : 'No playlists yet';
      }

      if (playlistsList) {
        playlistsList.innerHTML = '';
        list.forEach((pl) => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'playlist-pill';
          if (pl.id === activePlaylistId) pill.classList.add('active');
          pill.dataset.playlistId = pl.id || '';

          const count = Array.isArray(pl.tracks) ? pl.tracks.length : 0;
          const countLabel = count ? `${count} track${count === 1 ? '' : 's'}` : 'Empty';
          const label = pl.name ? `${pl.name} • ${countLabel}` : countLabel;
          pill.textContent = label;

          pill.addEventListener('click', () => {
            if (pl.id === activePlaylistId) setActivePlaylist(null);
            else setActivePlaylist(pl.id);
          });

          playlistsList.appendChild(pill);
        });
      }

      if (playlistsEmpty) {
        playlistsEmpty.hidden = list.length > 0 || playlistsLoading;
      }

      if (playlistCreateForm) {
        playlistCreateForm.hidden = false;
      }

      renderPlaylistTracks();
      updateNowPlayingUI();
    }

    function renderPlaylistTracks(){
      if (!playlistTracksSection) return;
      const hasUser = Boolean(currentUser);
      const playlist = getActivePlaylist();

      if (!hasUser) {
        playlistTracksSection.hidden = true;
        if (deletePlaylistButton) deletePlaylistButton.hidden = true;
        if (togglePlaylistTracksButton) togglePlaylistTracksButton.hidden = true;
        return;
      }

      if (!playlist) {
        playlistTracksCollapsed = false;
        if (playlistTracksTitle) playlistTracksTitle.textContent = 'Playlist';
        if (playlistTracksMeta) playlistTracksMeta.textContent = '';
        if (playlistTracksList) playlistTracksList.innerHTML = '';
        if (playlistTracksEmpty) playlistTracksEmpty.hidden = true;
        if (deletePlaylistButton) deletePlaylistButton.hidden = true;
        if (togglePlaylistTracksButton) togglePlaylistTracksButton.hidden = true;
        playlistTracksSection.hidden = true;
        return;
      }

      playlistTracksSection.hidden = false;
      playlistTracksSection.classList.toggle('collapsed', playlistTracksCollapsed);

      const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
      const count = tracks.length;

      if (playlistTracksTitle) playlistTracksTitle.textContent = playlist.name || 'Playlist';
      if (playlistTracksMeta) {
        const countText = count ? `${count} track${count === 1 ? '' : 's'}` : 'No tracks yet';
        let display = countText;
        if (playlistTracksCollapsed && count) display += ' • hidden';
        playlistTracksMeta.textContent = display;
        playlistTracksMeta.hidden = false;
      }

      if (deletePlaylistButton) {
        deletePlaylistButton.hidden = false;
        deletePlaylistButton.disabled = playlistsLoading;
      }

      if (togglePlaylistTracksButton) {
        const hideToggle = count === 0;
        togglePlaylistTracksButton.hidden = hideToggle;
        if (!hideToggle) {
          togglePlaylistTracksButton.textContent = playlistTracksCollapsed ? 'Show tracks' : 'Hide tracks';
        }
      }

      if (playlistTracksList) {
        const previousPlaylistState = (currentRow && currentRow._playlist)
          ? {
              playlistId: currentRow._playlist,
              src: currentRow._src,
              playing: !player.paused && currentSrc === currentRow._src
            }
          : null;
        let matchedPlayback = false;

        playlistTracksList.innerHTML = '';

        tracks.forEach((track, idx) => {
          const li = document.createElement('li');
          li.className = 'track playlist-track';

          const contentWrap = document.createElement('div');
          contentWrap.className = 'playlist-track-content';

          const top = document.createElement('div');
          top.className = 'track-top';

          const titleWrap = document.createElement('div');
          titleWrap.className = 'track-title';
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          const seq = Number.isFinite(track?.seq) ? `${track.seq}. ` : `${idx + 1}. `;
          nameEl.textContent = `${seq}${track?.name || 'Track'}`;
          titleWrap.appendChild(nameEl);

          if (track?.trackArtist) {
            const artistLine = document.createElement('div');
            artistLine.className = 'artist';
            artistLine.textContent = track.trackArtist;
            titleWrap.appendChild(artistLine);
          }

          const playControl = document.createElement('div');
          playControl.className = 'play-control';
          const btnPlay = document.createElement('button');
          btnPlay.className = 'btn small';
          const srcCandidate = track?.resolvedSrc || track?.mp3 || '';
          const audioField = typeof track?.audioField === 'string' ? track.audioField.trim() : '';
          const artworkField = typeof track?.artworkField === 'string' ? track.artworkField.trim() : '';
          const playableCandidate = resolvePlayableSrc(srcCandidate || track?.mp3 || '');
          const playableSrc = canValidateAudioSrc(playableCandidate) ? playableCandidate : '';
          li._src = playableSrc;
          li._btn = btnPlay;
          li._card = null;
          li._playlist = playlist.id;
          li._audioField = audioField;
          li._valid = null;
          li._validated = false;
          li._validating = false;
          if (track?.id) li.dataset.trackId = track.id;
          else if (track?.trackRecordId) li.dataset.trackId = track.trackRecordId;

          if (playableSrc) {
            btnPlay.textContent = '▶ Play';
            btnPlay.disabled = false;
            btnPlay.classList.remove('btn-error');
          } else {
            btnPlay.textContent = 'No audio';
            btnPlay.disabled = true;
            btnPlay.classList.add('btn-error');
          }

          btnPlay.addEventListener('click', async () => {
            if (!li._src) {
              window.alert('This track has no playable audio source.');
              return;
            }
            if (li._valid === false) {
              btnPlay.textContent = 'Unavailable';
              btnPlay.disabled = true;
              btnPlay.classList.add('btn-error');
              return;
            }

            if (li._playlist && track?.trackRecordId) {
              const previousLabel = btnPlay.textContent;
              btnPlay.disabled = true;
              btnPlay.textContent = 'Refreshing…';
              const oldKey = String(li._src || '').trim();
              if (oldKey) audioProbeCache.delete(oldKey);
              const refreshed = await refreshTrackContainerSource(li, {
                recordId: track.trackRecordId,
                audioField: audioField,
                candidates: AUDIO_FIELD_CANDIDATES,
                forceRefresh: true
              });
              btnPlay.disabled = false;
              btnPlay.textContent = previousLabel;
              if (refreshed?.notFound) {
                li._src = '';
                li._meta.src = '';
                li._valid = false;
                btnPlay.textContent = 'Unavailable';
                btnPlay.disabled = true;
                btnPlay.classList.add('btn-error');
                return;
              }
              if (refreshed && refreshed.src) {
                const newSrc = refreshed.src;
                li._src = newSrc;
                li._meta.src = newSrc;
                if (refreshed.audioField) {
                  li._audioField = refreshed.audioField;
                  li._meta.audioField = refreshed.audioField;
                }
                if (track) {
                  track.resolvedSrc = refreshed.src;
                  track.mp3 = refreshed.rawUrl;
                  if (refreshed.audioField) track.audioField = refreshed.audioField;
                }
              }
            }

            handlePlay(btnPlay, li, li._src);

            if (li._valid === true || li._validating) return;
            li._validating = true;
            validateAudio(li, li._src, { optimistic: true }).finally(() => {
              li._validating = false;
            });
          });

          playControl.appendChild(btnPlay);
          top.appendChild(playControl);
          top.appendChild(titleWrap);
          contentWrap.appendChild(top);

          const metaLine = [track?.albumTitle, track?.albumArtist].filter(Boolean).join(' • ');
          if (metaLine) {
            const metaEl = document.createElement('div');
            metaEl.className = 'muted';
            metaEl.textContent = metaLine;
            contentWrap.appendChild(metaEl);
          }

          const metaButtonsWrap = document.createElement('div');
          metaButtonsWrap.className = 'playlist-track-meta-buttons';

          if (track.producer) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn small';
            btn.textContent = 'Producer';
            btn.addEventListener('click', () => openTrackInfoModal(track, btn));
            metaButtonsWrap.appendChild(btn);
          }

          const composerValues = [track.composer1, track.composer2, track.composer3, track.composer4];
          if (Array.isArray(track.composers)) composerValues.push(...track.composers);
          if (composerValues.filter(Boolean).length) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn small';
            btn.textContent = 'Composer';
            btn.addEventListener('click', () => openTrackInfoModal(track, btn));
            metaButtonsWrap.appendChild(btn);
          }

          if (metaButtonsWrap.childNodes.length) {
            contentWrap.appendChild(metaButtonsWrap);
          }

          const progWrap = document.createElement('div');
          progWrap.className = 'progress';
          const seek = document.createElement('input');
          seek.type = 'range';
          seek.className = 'seek';
          seek.min = 0;
          seek.max = 100;
          seek.value = 0;
          const time = document.createElement('div');
          time.className = 'time';
          time.textContent = '0:00 / 0:00';
          progWrap.appendChild(seek);
          progWrap.appendChild(time);
          contentWrap.appendChild(progWrap);
          li._seek = seek;
          li._time = time;
          li._seeking = false;

          seek.addEventListener('input', () => {
            if (currentRow === li && player.duration && Number.isFinite(player.duration)) {
              const pct = Number(seek.value) / 100;
              player.currentTime = pct * player.duration;
            }
          });
          seek.addEventListener('change', () => {
            if (currentRow === li && player.duration && Number.isFinite(player.duration)) {
              const pct = Number(seek.value) / 100;
              player.currentTime = pct * player.duration;
            }
            li._seeking = false;
          });
          seek.addEventListener('pointerdown', () => { if (currentRow === li) li._seeking = true; });
          seek.addEventListener('pointerup', () => { if (currentRow === li) li._seeking = false; });

          const thumbWrap = document.createElement('div');
          thumbWrap.className = 'playlist-thumb';
          const artworkRaw = typeof track?.artwork === 'string' ? track.artwork.trim() : '';
          if (artworkRaw) {
            const img = document.createElement('img');
            img.src = `/api/container?u=${encodeURIComponent(artworkRaw)}`;
            img.alt = 'Artwork';
            img.onerror = () => {
              thumbWrap.innerHTML = '';
              thumbWrap.textContent = 'No art';
            };
            thumbWrap.appendChild(img);
          } else {
            thumbWrap.textContent = 'No art';
          }

          li.appendChild(thumbWrap);
          li.appendChild(contentWrap);
          const baseMeta = { ...track };
          baseMeta.trackName = track?.name || `Track ${idx + 1}`;
          baseMeta.trackArtist = track?.trackArtist || track?.albumArtist || '';
          baseMeta.albumTitle = track?.albumTitle || '';
          baseMeta.albumArtist = track?.albumArtist || '';
          baseMeta.playlistId = playlist.id;
          baseMeta.playlistName = playlist.name || '';
          baseMeta.picture = track?.artwork || '';
          baseMeta.source = 'playlist';
          baseMeta.catalogue = track?.catalogue || '';
          baseMeta.playlistTrackId = track?.id || '';
          baseMeta.trackRecordId = track?.trackRecordId || '';
          baseMeta.audioField = audioField;
          baseMeta.pictureField = artworkField;
          baseMeta.src = playableSrc;
          baseMeta.producer = track?.producer || '';
          baseMeta.composer1 = track?.composer1 || '';
          baseMeta.composer2 = track?.composer2 || '';
          baseMeta.composer3 = track?.composer3 || '';
          baseMeta.composer4 = track?.composer4 || '';
          baseMeta.composers = track?.composers || [];
          li._meta = baseMeta;
          playlistTracksList.appendChild(li);

          if (
            playableSrc &&
            previousPlaylistState &&
            previousPlaylistState.playlistId === playlist.id &&
            previousPlaylistState.src === playableSrc
          ) {
            matchedPlayback = true;
            currentRow = li;
            currentBtn = btnPlay;
            li._playlist = playlist.id;
            if (previousPlaylistState.playing) {
              li.classList.add('playing');
              btnPlay.textContent = '⏸ Pause';
              btnPlay.classList.add('btn-accent');
              btnPlay.disabled = false;
            } else {
              btnPlay.textContent = '▶ Play';
              btnPlay.classList.remove('btn-accent');
            }
            setNowPlayingFromRow(li, previousPlaylistState.playing);
          }
        });

        if (previousPlaylistState) {
          if (previousPlaylistState.playlistId === playlist.id) {
            if (!matchedPlayback) {
              if (previousPlaylistState.playing && !player.paused && currentSrc === previousPlaylistState.src) {
                player.pause();
              }
              currentSrc = '';
              updateButtonsForStop();
            } else {
              updateProgressUI();
            }
          } else if (previousPlaylistState.playing && !player.paused && currentSrc === previousPlaylistState.src) {
            player.pause();
            currentSrc = '';
            updateButtonsForStop();
          }
        }

        playlistTracksList.hidden = playlistTracksCollapsed;
      }

      if (playlistTracksEmpty) {
        playlistTracksEmpty.hidden = playlistTracksCollapsed || count > 0;
        playlistTracksEmpty.textContent = 'No tracks in this playlist yet.';
      }
      syncPlaylistOnlyCurrent();
    }

    async function deletePlaylistOnServer(id){
      const res = await fetch(`/api/playlists/${encodeURIComponent(id)}`, {
        method: 'DELETE',
        headers: {
          'Accept': 'application/json'
        }
      });
      let json = {};
      try { json = await res.json(); } catch {}
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (res.status === 404) {
        return null;
      }
      if (!res.ok) {
        throw new Error(json?.error || 'Failed to delete playlist');
      }
      return json?.playlist || null;
    }

    async function deleteActivePlaylist(){
      const playlist = getActivePlaylist();
      if (!playlist) return;
      const name = playlist.name || 'playlist';
      if (!window.confirm(`Delete ${name}? This cannot be undone.`)) return;
      if (deletePlaylistButton) deletePlaylistButton.disabled = true;
      try {
        await deletePlaylistOnServer(playlist.id);
      } catch (err) {
        window.alert(err?.message || 'Unable to delete playlist');
        if (deletePlaylistButton) deletePlaylistButton.disabled = false;
        return;
      }
      playlists = Array.isArray(playlists) ? playlists.filter((p) => p && p.id !== playlist.id) : [];
      playlistsLoaded = true;
      if (playlists.length) {
        activePlaylistId = playlists[0]?.id || null;
      } else {
        activePlaylistId = null;
      }
      if (nowPlayingInfo.meta && nowPlayingInfo.meta.playlistId === playlist.id) {
        try { player.pause(); } catch {}
        updateButtonsForStop();
        currentSrc = '';
        clearNowPlaying();
      }
      playlistTracksCollapsed = false;
      renderPlaylistsPanel();
      if (deletePlaylistButton) deletePlaylistButton.disabled = false;
      window.alert('Playlist deleted.');
    }

    async function handleAddToPlaylist(album, track, playableSrc){
      if (!currentUser) {
        openAuth('login');
        return;
      }
      await ensurePlaylistsLoaded();
      let playlist = getActivePlaylist();
      if (!playlist && playlists.length === 1) {
        playlist = playlists[0];
        setActivePlaylist(playlist.id);
      }

      if (!playlist) {
        let name = window.prompt('Add to playlist\nEnter playlist name (existing names will be reused):');
        if (!name) return;
        name = name.trim();
        if (!name) return;

        const existing = playlists.find((p) => typeof p?.name === 'string' && p.name.toLowerCase() === name.toLowerCase());
        if (existing) {
          playlist = existing;
          setActivePlaylist(existing.id);
        } else {
          try {
            playlist = await createPlaylistOnServer(name);
          } catch (err) {
            window.alert(err?.message || 'Unable to create playlist');
            return;
          }
        }
      }

      if (!playlist) {
        window.alert('Playlist unavailable. Select a playlist from the My Playlists panel.');
        return;
      }

      playlistTracksCollapsed = false;

      const payload = {
        recordId: typeof track.recordId === 'string' ? track.recordId : '',
        name: track.name || '',
        albumTitle: album?.title || '',
        albumArtist: album?.artist || '',
        catalogue: album?.catalogue || '',
        trackArtist: track.trackArtist || '',
        seq: Number.isFinite(track.seq) ? Number(track.seq) : null,
        mp3: track.mp3 || '',
        resolvedSrc: playableSrc || '',
        artwork: album?.picture || '',
        audioField: track.mp3Field || track.audioField || '',
        artworkField: album?.pictureField || track.pictureField || ''
      };

      try {
        const { duplicate } = await addTrackToPlaylistOnServer(playlist.id, payload);
        if (duplicate) {
          window.alert('Track already in playlist.');
        } else {
          window.alert(`Added to "${playlist.name}"`);
        }
      } catch (err) {
        window.alert(err?.message || 'Unable to add track');
      }
    }

    function openAuth(mode = authMode, trigger = null){
      setAuthMode(mode);
      clearAuthError();
      if (authOverlay) {
        authOverlay.hidden = false;
        authOverlay.classList.add('open');
      }
      authReturnFocus = trigger || document.activeElement;
      queueTask(() => {
        authEmail?.focus();
        authEmail?.select?.();
      });
    }

    function closeAuth(){
      if (authOverlay) {
        authOverlay.hidden = true;
        authOverlay.classList.remove('open');
      }
      setAuthBusy(false);
      clearAuthError();
      authForm?.reset();
      if (authReturnFocus && typeof authReturnFocus.focus === 'function') {
        authReturnFocus.focus();
      }
      authReturnFocus = null;
      setAuthMode('login');
    }

    async function refreshCurrentUser(){
      try {
        const res = await fetch('/api/auth/me', { headers: { 'Accept': 'application/json' } });
        if (!res.ok) throw new Error('Session check failed');
        const json = await res.json().catch(() => ({}));
        const email = json?.user?.email;
        currentUser = email ? { email } : null;
      } catch {
        currentUser = null;
      }
      if (currentUser) await loadUserPlaylists();
      else clearPlaylists();
      updateAuthUI();
    }

    async function submitAuthForm(event){
      event.preventDefault();
      if (!authEmail || !authPassword) return;
      const email = authEmail.value.trim();
      const password = authPassword.value;
      if (!email) {
        setAuthError('Email required');
        authEmail.focus();
        return;
      }
      if (password.length < 8) {
        setAuthError('Password must be at least 8 characters');
        authPassword.focus();
        return;
      }
      clearAuthError();
      setAuthBusy(true);
      try {
        const endpoint = authMode === 'register' ? '/api/auth/register' : '/api/auth/login';
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({ email, password })
        });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json?.ok) {
          const message = json?.error || 'Unable to complete request';
          setAuthError(message);
          return;
        }
        currentUser = json?.user?.email ? { email: json.user.email } : { email };
        updateAuthUI();
        await loadUserPlaylists();
        closeAuth();
      } catch (err) {
        setAuthError(err?.message || 'Network error');
      } finally {
        setAuthBusy(false);
      }
    }

    async function performLogout(){
      setAuthBusy(true);
      try {
        await fetch('/api/auth/logout', {
          method: 'POST',
          headers: { 'Accept': 'application/json' }
        });
      } catch {}
      currentUser = null;
      setAuthBusy(false);
      updateAuthUI();
      clearPlaylists();
    }


    // Raw FM rows (cumulative as we lazy-load)
    let rawItems = [];
    let rawTotalFound = 0;
    let rawNextOffset = 0; // UI 0-based; server converts to FM 1-based

    // Grouped albums & album-page state
    let albumGroups = [];
    let albumPage = 0;
    let currentMode = 'landing';
    let isRestoring = false;

    // Single audio UI state
    let currentBtn=null, currentRow=null, currentSrc='';

    // Audio validation caches
    const audioProbeCache = new Map(); // src -> { ok, reason, ts }
    const albumAudioState = new Map(); // albumKey -> { status, promise?, ts }
    const AUDIO_PROBE_TTL = 10 * 60 * 1000;
    let renderQueued = false;
    const queueTask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn);
    const containerCache = new Map(); // recordId|field -> cached container

    // Field helper mappings (adjust here if exact names differ)
    const AUDIO_FIELD_CANDIDATES = ['mp3', 'MP3', 'Audio File', 'Audio::mp3'];
    const ARTWORK_FIELD_CANDIDATES = ['Artwork::Picture', 'Artwork Picture', 'Picture'];

    function pickFieldValue(source, candidates){
      if (!source) return { value: '', field: '' };
      for (const candidate of candidates) {
        if (!Object.prototype.hasOwnProperty.call(source, candidate)) continue;
        const raw = source[candidate];
        if (raw === undefined || raw === null) continue;
        const str = typeof raw === 'string' ? raw.trim() : String(raw).trim();
        if (str) return { value: str, field: candidate };
      }
      return { value: '', field: '' };
        }

    function fCatalogue(f){
      return f['Album Catalogue Number'] || f['Album Catalog Number'] || f['Album Catalogue No'] || f['Catalogue'] || '';
        }
    function fPicture(f){
      return pickFieldValue(f, ARTWORK_FIELD_CANDIDATES).value;
        }
    const F_TRACK  = 'Track Name';
    const F_GENRE  = 'Local Genre';

    const TRACK_SEQUENCE_FIELDS = [
      'Track Number',
      'TrackNumber',
      'Track_Number',
      'Track No',
      'Track No.',
      'Track_No',
      'Track #',
      'Track#',
      'Track Sequence',
      'Track Sequence Number',
      'Track Seq',
      'Track Seq No',
      'Track Order',
      'Track Position',
      'TrackPosition',
      'Sequence',
      'Seq',
      'Sequence Number',
      'Sequence_Number',
      'Song Number',
      'Song No',
      'Song Seq',
      'Song Order',
      'Tape Files::Track Number',
      'Tape Files::Track_No'
    ];

    function composersFrom(f){
      const c = [
        f['Composer'],
        f['Composer 1'] ?? f['Composer1'],
        f['Composer 2'] ?? f['Composer2'],
        f['Composer 3'] ?? f['Composer3'],
        f['Composer 4'] ?? f['Composer4'],
      ].filter(Boolean);
      return c;
        }

    function parseTrackSequence(fields = {}) {
      for (const key of TRACK_SEQUENCE_FIELDS) {
        if (!Object.prototype.hasOwnProperty.call(fields, key)) continue;
        const raw = fields[key];
        if (raw === undefined || raw === null) continue;
        const str = String(raw).trim();
        if (!str) continue;
        const numeric = Number(str);
        if (Number.isFinite(numeric)) return numeric;
        const cleaned = Number(str.replace(/[^0-9.-]/g, ''));
        if (Number.isFinite(cleaned)) return cleaned;
      }
      for (const [key, value] of Object.entries(fields)) {
        if (value === undefined || value === null) continue;
        const lower = key.toLowerCase();
        if (!/(track|song)/.test(lower)) continue;
        if (!/(no|num|#|seq|order|pos)/.test(lower)) continue;
        const str = String(value).trim();
        if (!str) continue;
        const numeric = Number(str);
        if (Number.isFinite(numeric)) return numeric;
        const cleaned = Number(str.replace(/[^0-9.-]/g, ''));
        if (Number.isFinite(cleaned)) return cleaned;
      }
      return Number.POSITIVE_INFINITY;
        }

    
    // Flexible field accessors to match your layout keys
    function fTitle(f){
      return f['Album Title'] || f['Tape Files::Album_Title'] || f['Album_Title'] || f['Title'] || '';
        }
    function fArtist(f){
      return f['Album Artist'] || f['Tape Files::Album Artist'] || f['Track Artist'] || f['Artist'] || '';
        }
    function fMp3(f){
      return pickFieldValue(f, AUDIO_FIELD_CANDIDATES).value;
        }
    function fLang(f){
      return f['Language'] || f['Language Code'] || '';
        }

    function hasValidMp3(s){
      return canValidateAudioSrc(s);
        }

    function fmtTime(sec){
      const value = Number(sec);
      if (!Number.isFinite(value) || value <= 0) return '0:00';
      const clamped = Math.max(0, value);
      const minutes = Math.floor(clamped / 60);
      const seconds = Math.floor(clamped % 60);
      return `${minutes}:${String(seconds).padStart(2,'0')}`;
        }

    const AUDIO_VALIDATE_TIMEOUT = 12000;
    const AUDIO_VALIDATE_MAX_RETRIES = 2;
    const MAX_AUDIO_PROBES_PER_ALBUM = 2;
    const MAX_ALBUMS_TO_PRIME = ALBUMS_PER_PAGE * 2;
    const MAX_CONCURRENT_AUDIO_PROBES = 6;
    const AUDIO_PRELOAD_LIMIT = 4;
    let activeAudioProbes = 0;
    const audioProbeWaiters = [];
    const audioPreloadCache = new Map();
    const audioPreloadOrder = [];
    function delay(ms){ return new Promise((resolve) => setTimeout(resolve, ms)); }
    function canValidateAudioSrc(src){
      if (typeof src !== 'string') return false;
      const trimmed = src.trim();
      if (!trimmed) return false;
      if (trimmed.startsWith('/')) return true;
      if (/^https?:\/\//i.test(trimmed)) return true;
      if (/^[^:?#]+\.(mp3|m4a|aac|wav|ogg|flac)$/i.test(trimmed)) return true;
      return false;
        }

    function resolvePlayableSrc(rawSrc){
      const src = typeof rawSrc === 'string' ? rawSrc.trim() : '';
      if (!src) return '';
      if (src.startsWith('/api/container?')) return src;
      if (/^https?:\/\//i.test(src)) return `/api/container?u=${encodeURIComponent(src)}`;
      return src;
        }

    function scheduleAlbumRender(){
      if (renderQueued) return;
      renderQueued = true;
      queueTask(() => {
        renderQueued = false;
        renderAlbumPage();
      });
        }

    function isFresh(entry){
      if (!entry || typeof entry.ts !== 'number') return false;
      return (Date.now() - entry.ts) < AUDIO_PROBE_TTL;
        }

    async function acquireProbeSlot(){
      if (activeAudioProbes >= MAX_CONCURRENT_AUDIO_PROBES) {
        await new Promise((resolve) => audioProbeWaiters.push(resolve));
      }
      activeAudioProbes += 1;
    }

    function releaseProbeSlot(){
      activeAudioProbes = Math.max(0, activeAudioProbes - 1);
      const next = audioProbeWaiters.shift();
      if (next) next();
    }

    function releasePreloadedSrc(src){
      if (!src) return;
      const audio = audioPreloadCache.get(src);
      if (audio) {
        try {
          audio.src = '';
          audio.load();
        } catch {}
        audioPreloadCache.delete(src);
      }
      const idx = audioPreloadOrder.indexOf(src);
      if (idx !== -1) audioPreloadOrder.splice(idx, 1);
    }

    function preloadAudioSrc(src){
      if (!src || audioPreloadCache.has(src)) return;
      try {
        const audio = new Audio();
        audio.preload = 'auto';
        audio.src = src;
        try { audio.load(); } catch {}
        audioPreloadCache.set(src, audio);
        audioPreloadOrder.push(src);
      } catch {}
      while (audioPreloadOrder.length > AUDIO_PRELOAD_LIMIT) {
        const stale = audioPreloadOrder.shift();
        releasePreloadedSrc(stale);
      }
    }

    function updatePlaylistTrackEntry(meta, update){
      if (!meta || !meta.playlistId || !meta.playlistTrackId) return;
      const playlist = playlists.find((p) => p && p.id === meta.playlistId);
      if (!playlist || !Array.isArray(playlist.tracks)) return;
      const entry = playlist.tracks.find((t) => t && t.id === meta.playlistTrackId);
      if (!entry) return;
      if (update.resolvedSrc) {
        entry.resolvedSrc = update.resolvedSrc;
      }
      if (update.rawUrl) {
        entry.mp3 = update.rawUrl;
      }
      if (update.audioField) entry.audioField = update.audioField;
    }

        async function refreshTrackContainerSource(row, options = {}){
      const meta = row?._meta || {};
      const recordId = options.recordId || meta.trackRecordId || meta.recordId || '';
      if (!recordId) return null;

      const requestedField = options.audioField || meta.audioField || '';
      const cacheKey = `${recordId}::${requestedField || 'default'}`;
      const now = Date.now();
      const CACHE_TTL = 30 * 60 * 1000;
      const useCache = !options.forceRefresh;
      const cached = useCache ? containerCache.get(cacheKey) : null;
      if (cached && (now - cached.ts) < CACHE_TTL) {
        if (cached.notFound) return { notFound: true };
        if (row) {
          row._src = cached.resolvedSrc;
          if (row._meta) {
            row._meta.src = cached.resolvedSrc;
            if (cached.audioField) row._meta.audioField = cached.audioField;
            updatePlaylistTrackEntry(row._meta, { rawUrl: cached.rawUrl, resolvedSrc: cached.resolvedSrc, audioField: cached.audioField });
          }
          row._lastContainerRefresh = now;
        }
        return { ...cached };
      }

      if (options.forceRefresh) {
        containerCache.delete(cacheKey);
      }

      const params = new URLSearchParams();
      if (requestedField) {
        params.set('field', requestedField);
      } else if (Array.isArray(options.candidates) && options.candidates.length) {
        params.set('candidates', options.candidates.join(','));
      }

      try {
        const query = params.toString();
        const endpoint = query
          ? `/api/track/${encodeURIComponent(recordId)}/container?${query}`
          : `/api/track/${encodeURIComponent(recordId)}/container`;
        const res = await fetch(endpoint, { headers: { 'Accept': 'application/json' } });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json?.url) {
          return null;
        }
        const rawUrl = json.url;
        const field = json?.field || requestedField || '';
        const resolvedSrc = resolvePlayableSrc(rawUrl);

        if (row) {
          row._src = resolvedSrc;
          if (row._meta) {
            row._meta.src = resolvedSrc;
            if (field) row._meta.audioField = field;
            updatePlaylistTrackEntry(row._meta, { rawUrl, resolvedSrc, audioField: field });
          }
          row._lastContainerRefresh = now;
        }

        containerCache.set(cacheKey, { rawUrl, resolvedSrc, audioField: field, ts: now });
        return { src: resolvedSrc, rawUrl, audioField: field };
      } catch (err) {
        console.warn('[MASS] Failed to refresh container source', err);
        return null;
      }
    }

    function findNextPlayableRow(row){
      if (!row) return null;
      let pointer = row.nextElementSibling;
      while (pointer) {
        if (pointer._src) return pointer;
        pointer = pointer.nextElementSibling;
      }
      return null;
    }

    function scheduleNextTrackPreload(row){
      const nextRow = findNextPlayableRow(row);
      if (!nextRow || !nextRow._src || audioPreloadCache.has(nextRow._src)) return;
      preloadAudioSrc(nextRow._src);
    }

    async function probeAudioSource(src, attempt = 0){
      const key = String(src || '').trim();
      if (!key) {
        const outcome = { ok: false, reason: 'Invalid link', ts: Date.now() };
        return outcome;
      }
      const cached = audioProbeCache.get(key);
      if (cached && isFresh(cached)) return cached;

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), AUDIO_VALIDATE_TIMEOUT);
      let response;
      let outcome;
      await acquireProbeSlot();
      try {
        response = await fetch(src, {
          method: 'GET',
          headers: { Range: 'bytes=0-4095' },
          signal: controller.signal,
          cache: 'no-store',
          credentials: 'include'
        });
      } catch (err) {
        outcome = { ok: false, reason: err?.name === 'AbortError' ? 'Timeout' : 'Unavailable', ts: Date.now() };
        if (outcome.reason === 'Timeout' && attempt < AUDIO_VALIDATE_MAX_RETRIES) {
          await delay(600 * (attempt + 1));
          releaseProbeSlot();
          clearTimeout(timeoutId);
          return probeAudioSource(src, attempt + 1);
        }
        audioProbeCache.set(key, outcome);
        return outcome;
      } finally {
        clearTimeout(timeoutId);
        releaseProbeSlot();
      }
      let buffer;
      try {
        if (!response || !response.ok) {
          if (response && response.status === 401) {
            console.warn('[MASS] Audio probe received 401', src);
          }
          outcome = { ok: false, reason: `HTTP ${response ? response.status : 'error'}`, ts: Date.now() };
        } else {
          const type = (response.headers.get('content-type') || '').toLowerCase();
          const len = response.headers.get('content-length');
          if (len === '0') {
            outcome = { ok: false, reason: 'Empty audio', ts: Date.now() };
          } else if (type && !/(audio|mpeg|mp3|ogg|wav|flac)/i.test(type)) {
            outcome = { ok: false, reason: 'Unexpected content', ts: Date.now() };
          } else {
            buffer = await response.arrayBuffer();
            if (!buffer || buffer.byteLength === 0) {
              outcome = { ok: false, reason: 'Empty audio', ts: Date.now() };
            } else {
              const bytes = new Uint8Array(buffer);
              if (!looksLikeAudio(bytes, type)) {
                outcome = { ok: false, reason: 'Unexpected content', ts: Date.now() };
              } else {
                outcome = { ok: true, ts: Date.now(), type, length: len ? Number(len) : undefined };
              }
            }
          }
        }
      } catch (err) {
        outcome = { ok: false, reason: 'Unavailable', ts: Date.now() };
      } finally {
        if (response && response.body && typeof response.body.cancel === 'function') {
          try { response.body.cancel(); } catch (_) {}
        }
      }

      if (!outcome.ok && outcome.reason === 'Timeout' && attempt < AUDIO_VALIDATE_MAX_RETRIES) {
        await delay(600 * (attempt + 1));
        return probeAudioSource(src, attempt + 1);
      }
      audioProbeCache.set(key, outcome);
      return outcome;
        }

    function looksLikeAudio(bytes, type){
      if (!bytes || !bytes.length) return false;
      const first = bytes[0];
      const second = bytes.length > 1 ? bytes[1] : 0;
      const third = bytes.length > 2 ? bytes[2] : 0;
      const fourth = bytes.length > 3 ? bytes[3] : 0;
      const head = String.fromCharCode(first, second, third, fourth);
      const nextHead = bytes.length >= 8 ? String.fromCharCode(bytes[4], bytes[5], bytes[6], bytes[7]) : '';

      const startsWith = (prefix) => head.startsWith(prefix);

      if (startsWith('ID3')) return true;
      if (startsWith('OggS')) return true;
      if (startsWith('fLaC')) return true;
      if (startsWith('RIFF')) return true;
      if (startsWith('FORM')) return true; // AIFF/AIFF-C
      if (head.startsWith('ftyp') || nextHead === 'ftyp') return true; // MP4/M4A

      if (first === 0xFF && (second & 0xE0) === 0xE0) return true; // MPEG frame sync
      if (first === 0xAD && second === 0xAF) return true; // ADPCM

      // Common non-audio signatures
      if (first === 0x3C /* < */ || first === 0x7B /* { */ || first === 0x5B /* [ */) return false;
      if (head.toLowerCase().startsWith('http')) return false;

      if (type && /(audio|mpeg|mp3|ogg|wav|flac|aac)/i.test(type)) return true;

      return false;
        }

    function ensureAlbumAudioValidation(album){
      if (!album) return;
      const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
      album.key = key;
      const existing = albumAudioState.get(key);
      if (existing) {
        if (existing.status === 'pending') return;
        if ((existing.status === 'valid' || existing.status === 'invalid') && isFresh(existing)) return;
      }

      const validator = runAlbumAudioValidation(album);
      album._pendingValidation = true;
      albumAudioState.set(key, { status: 'pending', promise: validator });
      validator
        .then((ok) => {
          albumAudioState.set(key, { status: ok ? 'valid' : 'invalid', ts: Date.now() });
          album._pendingValidation = false;
          scheduleAlbumRender();
        })
        .catch((err) => {
          console.warn('[MASS] Album audio validation failed', err);
          albumAudioState.set(key, { status: 'invalid', ts: Date.now(), error: err });
          album._pendingValidation = false;
          scheduleAlbumRender();
        });
        }

    function primeAlbumAudioValidation(albums, limit = MAX_ALBUMS_TO_PRIME){
      if (!Array.isArray(albums) || !albums.length || limit <= 0) return;
      let processed = 0;
      for (const album of albums) {
        if (!album) continue;
        const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
        album.key = key;
        ensureAlbumAudioValidation(album);
        processed += 1;
        if (processed >= limit) break;
      }
        }

    async function runAlbumAudioValidation(album){
      const tracks = Array.isArray(album.tracks) ? album.tracks : [];
      if (!tracks.length) return false;
      const sources = [];
      const seen = new Set();
      for (const track of tracks) {
        const src = resolvePlayableSrc(track && track.mp3);
        if (!canValidateAudioSrc(src)) return false;
        if (seen.has(src)) continue;
        seen.add(src);
        sources.push(src);
        if (sources.length >= MAX_AUDIO_PROBES_PER_ALBUM) break;
      }
      if (!sources.length) return false;
      const results = await Promise.all(sources.map((src) => probeAudioSource(src)));
      return results.some((outcome) => outcome && outcome.ok);
        }

    async function validateAudio(row, src, options = {}){
      const btn = row && row._btn;
      const card = row && row._card;
      if (!btn) return;
      const token = Symbol('audio-validate');
      row._validationToken = token;
      const { optimistic = false } = options;

      const applyIfCurrent = (fn) => {
        if (row._validationToken !== token) return false;
        fn();
        return true;
      };

      const finalizeCard = (isValid) => {
        if (!card) return;
        let pending = Number(card.dataset.pendingTracks || '0');
        if (pending > 0) pending -= 1;
        card.dataset.pendingTracks = String(pending);
        if (isValid) {
          const valid = Number(card.dataset.validTracks || '0') + 1;
          card.dataset.validTracks = String(valid);
        }
        syncCardAudioState(card);
      };

      const setInvalid = (label) => {
        const applied = applyIfCurrent(() => {
          if (optimistic && currentRow === row && currentSrc === src) {
            player.pause();
            updateButtonsForStop();
          }
          btn.disabled = true;
          btn.textContent = label || 'Unavailable';
          btn.classList.add('btn-error');
          btn.classList.remove('btn-accent');
          btn.title = label || 'Audio unavailable';
          row._valid = false;
          row._validated = true;
          releasePreloadedSrc(src);
        });
        if (applied) finalizeCard(false);
      };

      const setValid = () => {
        const applied = applyIfCurrent(() => {
          if (!(currentRow === row && !player.paused)) {
            btn.textContent = '▶ Play';
          }
          btn.disabled = false;
          btn.classList.remove('btn-error');
          btn.removeAttribute('title');
          row._valid = true;
          row._validated = true;
        });
        if (applied) finalizeCard(true);
      };

      if (!canValidateAudioSrc(src)) {
        if (card) card.dataset.hasAudioCandidates = 'true';
        setInvalid('Invalid link');
        return;
      }

      if (card) card.dataset.hasAudioCandidates = 'true';

      const key = typeof src === 'string' ? src.trim() : '';
      const cachedOutcome = key ? audioProbeCache.get(key) : null;
      if (cachedOutcome && isFresh(cachedOutcome) && cachedOutcome.reason !== 'Timeout') {
        if (cachedOutcome.ok) {
          setValid();
        } else {
          setInvalid(cachedOutcome.reason || 'Unavailable');
        }
        return;
      }

      const applied = applyIfCurrent(() => {
        if (!optimistic) {
          btn.disabled = true;
          btn.textContent = 'Checking…';
          btn.title = 'Validating audio…';
        }
        btn.classList.remove('btn-error');
        row._validating = true;
        if (card) {
          const pending = Number(card.dataset.pendingTracks || '0') + 1;
          card.dataset.pendingTracks = String(pending);
          syncCardAudioState(card);
        }
      });
      if (!applied) return;

      let currentSrcKey = key;
      let outcome = await probeAudioSource(src);

      if (!outcome.ok && /401/.test(String(outcome.reason || '')) && row) {
        const refreshed = await refreshTrackContainerSource(row, {
          recordId: row._meta?.trackRecordId || row._meta?.recordId,
          audioField: row._meta?.audioField || row._audioField || '',
          candidates: AUDIO_FIELD_CANDIDATES,
          forceRefresh: true
        });
        if (refreshed?.notFound) {
          row._src = '';
          setInvalid('Unavailable');
          row._validating = false;
          return;
        }
        if (refreshed && refreshed.src) {
          const newSrc = refreshed.src;
          currentSrcKey = String(newSrc || '').trim();
          audioProbeCache.delete(key);
          key = currentSrcKey;
          src = newSrc;
          outcome = await probeAudioSource(newSrc);
        }
      }

      if (outcome.ok) {
        setValid();
        if (optimistic && currentRow === row && player.paused && row._src) {
          queueTask(() => {
            if (row._btn) handlePlay(row._btn, row, row._src);
          });
        }
      } else {
        setInvalid(outcome.reason || 'Unavailable');
      }
      row._validating = false;
        }

    function syncCardAudioState(card){
      if (!card) return;
      const hasCandidates = card.dataset.hasAudioCandidates === 'true';
      const valid = Number(card.dataset.validTracks || '0');
      const pending = Number(card.dataset.pendingTracks || '0');
      if (valid > 0) {
        card.classList.remove('no-audio');
        if (card.title === 'No playable audio available') card.removeAttribute('title');
      } else if (!hasCandidates || pending === 0) {
        card.classList.add('no-audio');
        if (!card.title) card.title = 'No playable audio available';
      }
        }

    function abortInFlight(){ if(inFlight){ inFlight.abort(); inFlight=null; } }

    function snapshotState(overrides = {}){
      return {
        groups: albumGroups.slice(),
        page: albumPage,
        rawItems: rawItems.slice(),
        rawTotalFound,
        rawNextOffset,
        lastQ,
        searchValue: searchEl ? searchEl.value : '',
        mode: currentMode,
        ...overrides
      };
        }

    function applySnapshot(snapshot){
      if (!snapshot) return;
      albumGroups = Array.isArray(snapshot.groups) ? snapshot.groups.slice() : [];
      rawItems = Array.isArray(snapshot.rawItems) ? snapshot.rawItems.slice() : [];
      rawTotalFound = typeof snapshot.rawTotalFound === 'number' ? snapshot.rawTotalFound : rawItems.length;
      rawNextOffset = typeof snapshot.rawNextOffset === 'number' ? snapshot.rawNextOffset : rawItems.length;
      albumPage = typeof snapshot.page === 'number' ? snapshot.page : 0;
      lastQ = typeof snapshot.lastQ === 'string' ? snapshot.lastQ : '';
      currentMode = snapshot.mode || 'search';
      primeAlbumAudioValidation(albumGroups);
      if (searchEl && typeof snapshot.searchValue === 'string') {
        searchEl.value = snapshot.searchValue;
      }
      hideLanding();
      errorEl.hidden = true;
        }

    function restorePreviousSearch(){
      if (!prevSearch) return;
      const restore = prevSearch;
      prevSearch = null;

      const source = restore.snapshot || restore.paging || restore.original;
      if (source) {
        const snapshot = { ...source };
        if (restore.type === 'search' && typeof restore.term === 'string') {
          snapshot.lastQ = restore.term;
          snapshot.searchValue = restore.term;
        }
        isRestoring = true;
        applySnapshot(snapshot);
        renderAlbumPage();

        const needsRefetch = albumGroups.length <= 1 && ((restore.type === 'search' && typeof restore.term === 'string' && restore.term.trim()) || (restore.type === 'explore' && restore.start));
        if (needsRefetch) {
          if (restore.type === 'search') {
            if (searchEl) searchEl.value = restore.term;
            run(restore.term);
            return;
          } else if (restore.type === 'explore') {
            const startYear = Number(restore.start) || 0;
            if (startYear) {
              runExplore(startYear);
              return;
            }
          }
          isRestoring = false;
          return;
        }

        isRestoring = false;
        return;
      }

      if (restore.type === 'explore' && restore.start) {
        const startYear = Number(restore.start) || 0;
        if (startYear) {
          isRestoring = true;
          runExplore(startYear);
          return;
        }
      }

      if (restore.type === 'search' && typeof restore.term === 'string' && restore.term.trim()) {
        if (searchEl) searchEl.value = restore.term;
        isRestoring = true;
        run(restore.term);
        return;
      }
        }

    // Show placeholder graphic from /img/* until user searches
    function showLanding(){
      currentMode = 'landing';
      prevSearch = null;
      rawItems = [];
      rawTotalFound = 0;
      rawNextOffset = 0;
      albumGroups = [];
      albumPage = 0;
      audioProbeCache.clear();
      albumAudioState.clear();
      // Clear albums UI
      albumsEl.innerHTML = '';
      albumsEl.classList.remove('single-album');
      pagerEl.hidden = true;
      countEl.textContent = '';
      errorEl.hidden = true;
      // Try a few common placeholder names; fall back to MAD_Logo.png
      const candidates = ['placeholder.png','placeholder.svg','landing.png','MAD_placeholder.png','MAD_Logo.png'];
      const img = document.createElement('img');
      let i = 0;
      function tryNext(){
        if(i >= candidates.length){ landingEl.innerHTML = ''; return; }
        img.src = '/img/' + candidates[i++];
      }
      img.alt = 'Placeholder';
      img.onerror = tryNext;
      landingEl.innerHTML = '';
      landingEl.appendChild(img);
      landingEl.style.display = 'flex';
      tryNext();
        }

    
    function hideLanding(){ landingEl.style.display = 'none'; }

    function doSearch(q){
      abortInFlight();
      const ctrl = new AbortController();
      inFlight = ctrl;
      const params = new URLSearchParams();
      if (q) params.set('q', q);
      params.set('offset', 0);
      params.set('limit',  FM_FETCH_LIMIT);
      return fetch(`/api/search?${params}`, { signal: ctrl.signal })
        .then(async r => {
          if (!r.ok) throw new Error(await r.text().catch(() => `HTTP ${r.status}`));
          return r.json();
        })
        .finally(() => { if (inFlight === ctrl) inFlight = null; });
        }


    // Strong normalization to reduce bogus “same album different title”
    function normTitle(s){
      return String(s||'')
        .replace(/\s+/g,' ')
        .replace(/[\u2018\u2019]/g,"'")
        .replace(/[\u201C\u201D]/g,'"')
        .replace(/^\W+|\W+$/g,'') // trim leading/trailing punctuation
        .trim();
        }
    function keyTitle(s){ return normTitle(s).toLowerCase(); }

    function makeAlbumKey(catalogue, title, artist){
      const cat = String(catalogue || '').trim();
      if (cat) return `cat:${cat.toLowerCase()}`;
      const normT = normTitle(title || '').toLowerCase();
      const normA = normTitle(artist || '').toLowerCase();
      return `title:${normT}|artist:${normA}`;
        }

    function groupAlbums(items){
      const byCat = new Map();

      for (const rec of items) {
        const f = rec.fields || {};
        const cat = fCatalogue(f) || '__NO_CAT__';
        const title = normTitle(fTitle(f) || '(no album)');
        const artist= normTitle(fArtist(f) || '');
        const trackArtist = normTitle(f['Track Artist'] || f['Tape Files::Track Artist'] || '');
        const pictureInfo = pickFieldValue(f, ARTWORK_FIELD_CANDIDATES);
        const pic   = String(pictureInfo.value || '').trim();
        const pictureField = pictureInfo.field || '';
        const track = normTitle(f[F_TRACK] || '');
        const mp3Info = pickFieldValue(f, AUDIO_FIELD_CANDIDATES);
        const mp3   = mp3Info.value || '';
        const mp3Field = mp3Info.field || '';
        const genre = normTitle(f[F_GENRE] || '');
        const comps = composersFrom(f).map(value => normTitle(value || ''));
        const prod  = normTitle(f['Producer'] || '');
        const lang  = normTitle(fLang(f) || '');
        const composer1 = normTitle(f['Composer'] || f['Composer 1'] || f['Composer1'] || '');
        const composer2 = normTitle(f['Composer 2'] || f['Composer2'] || '');
        const composer3 = normTitle(f['Composer 3'] || f['Composer3'] || '');
        const composer4 = normTitle(f['Composer 4'] || f['Composer4'] || '');
        const isrc = (f['ISRC'] || '').trim();

        if(!byCat.has(cat)){
          byCat.set(cat, {
            catalogue: cat === '__NO_CAT__' ? '' : cat,
            titles: new Map(), // keyTitle -> {raw,count}
            artist,
            picture: pic || '',
            pictureField: pictureField || '',
            tracks: []
          });
        }
        const g = byCat.get(cat);

        const kt = keyTitle(title);
        const entry = g.titles.get(kt) || { raw: title, count: 0 };
        entry.count += 1; g.titles.set(kt, entry);

        if(!g.picture && pic) {
          g.picture = pic;
          g.pictureField = pictureField;
        }
        if(!g.artist && artist) g.artist = artist;

        // keep all tracks for title logic; mp3 validity filtered later
        if(track){
          const orderIndex = g.tracks.length;
          g.tracks.push({
            name: track,
            mp3,
            mp3Field,
            genre,
            composers: comps,
            producer: prod,
            language: lang,
            trackArtist,
            pictureField,
            composer1,
            composer2,
            composer3,
            composer4,
            isrc,
            seq: parseTrackSequence(f),
            recordId: rec.recordId || '',
            _order: orderIndex
          });
        }
      }

      const groups = [];
      for(const g of byCat.values()){
        const trimmedPicture = (g.picture || '').trim();
        if (!trimmedPicture) continue;

        if (!g.tracks.length) continue;

        const playableTracks = g.tracks.filter(t => hasValidMp3(t.mp3));
        if (!playableTracks.length) continue;

        const tracksForDisplay = playableTracks.map(track => ({ ...track }));

        // Ignore title candidates that equal any track name (prevents “Sunday Afternoon” issue)
        const trackKeys = new Set(g.tracks.map(t => keyTitle(t.name)));
        const candidates = Array.from(g.titles.entries()); // [keyTitle, {raw,count}]
        const filtered = candidates.filter(([kt]) => !trackKeys.has(kt));

        const pickFrom = (arr) => arr.reduce((best, cur) => (!best || cur[1].count > best[1].count) ? cur : best, null);
        const pickedPair = pickFrom(filtered.length ? filtered : candidates);
        const displayTitle = pickedPair ? pickedPair[1].raw : '(no album)';

        // Sort playable tracks (replace with Track No if available)
        tracksForDisplay.sort((a, b) => {
          const aSeq = Number(a.seq);
          const bSeq = Number(b.seq);
          const aFinite = Number.isFinite(aSeq);
          const bFinite = Number.isFinite(bSeq);
          if (aFinite && bFinite && aSeq !== bSeq) return aSeq - bSeq;
          if (aFinite && !bFinite) return -1;
          if (!aFinite && bFinite) return 1;
          const aOrder = Number.isFinite(a._order) ? a._order : Number.POSITIVE_INFINITY;
          const bOrder = Number.isFinite(b._order) ? b._order : Number.POSITIVE_INFINITY;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });

        const albumKey = makeAlbumKey(g.catalogue, displayTitle, g.artist);
        const hasPlayable = true;
        groups.push({
          catalogue: g.catalogue,
          title: displayTitle,
          artist: g.artist,
          picture: trimmedPicture,
          pictureField: g.pictureField || '',
          tracks: tracksForDisplay,
          hasPlayable,
          key: albumKey
        });
      }

      groups.sort((a,b)=> a.title.localeCompare(b.title, undefined, { sensitivity:'base' }) || a.artist.localeCompare(b.artist, undefined, { sensitivity:'base' }));
      return groups;
        }

    /* ================= Modal behavior ================= */
    function closeTrackInfoModal(options = {}) {
      if (!trackInfoOverlay.classList.contains('open')) return;
      trackInfoOverlay.classList.remove('open');
      trackInfoOverlay.hidden = true;
      trackInfoBody.innerHTML = '';
      document.removeEventListener('keydown', handleTrackInfoKeydown, true);
      if (!options.suppressFocus && trackInfoReturnFocus && typeof trackInfoReturnFocus.focus === 'function') {
        trackInfoReturnFocus.focus();
      }
      trackInfoReturnFocus = null;
      trackInfoFocusables = [];
        }

    function collectTrackMetadata(track){
      if (!track) return [];
      const entries = [];
      const pushEntry = (label, value) => {
        if (value === undefined || value === null) return;
        const text = String(value).trim();
        if (text) entries.push({ label, value: text });
      };
      pushEntry('Producer', track.producer);
      pushEntry('Track Artist', track.trackArtist);
      const composerPartsSet = new Set([
        track.composer1,
        track.composer2,
        track.composer3,
        track.composer4
      ].filter(Boolean).map(value => String(value).trim()).filter(Boolean));
      if (!composerPartsSet.size && Array.isArray(track.composers)) {
        track.composers.forEach((value) => {
          const trimmed = String(value || '').trim();
          if (trimmed) composerPartsSet.add(trimmed);
        });
      }
      if (composerPartsSet.size) {
        pushEntry('Composer', Array.from(composerPartsSet).join(', '));
      }
      pushEntry('Language', track.language);
      pushEntry('Genre', track.genre);
      pushEntry('ISRC', track.isrc);
      return entries;
        }

    function openTrackInfoModal(track, trigger) {
      if (!track) return;
      closeTrackInfoModal({ suppressFocus: true });
      trackInfoReturnFocus = trigger || null;

      const entries = collectTrackMetadata(track);

      if (entries.length) {
        const dl = document.createElement('dl');
        entries.forEach(({ label, value }) => {
          const dt = document.createElement('dt'); dt.textContent = label;
          const dd = document.createElement('dd'); dd.textContent = value;
          dl.appendChild(dt); dl.appendChild(dd);
        });
        trackInfoBody.innerHTML = '';
        trackInfoBody.appendChild(dl);
      } else {
        trackInfoBody.innerHTML = '<p class="info-modal-empty">No additional metadata.</p>';
      }

      trackInfoOverlay.hidden = false;
      trackInfoOverlay.classList.add('open');
      trackInfoFocusables = Array.from(trackInfoDialog.querySelectorAll(trackInfoFocusableSelector));
      if (trackInfoFocusables.length === 0) {
        trackInfoDialog.setAttribute('tabindex', '-1');
        trackInfoFocusables = [trackInfoDialog];
      } else {
        trackInfoDialog.removeAttribute('tabindex');
      }
      const focusTarget = trackInfoFocusables[0] || trackInfoDialog;
      requestAnimationFrame(() => focusTarget.focus());
      document.addEventListener('keydown', handleTrackInfoKeydown, true);
        }

    function handleTrackInfoKeydown(e) {
      if (!trackInfoOverlay.classList.contains('open')) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        closeTrackInfoModal();
        return;
      }
      if (e.key === 'Tab' && trackInfoFocusables.length) {
        const first = trackInfoFocusables[0];
        const last = trackInfoFocusables[trackInfoFocusables.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
        }

    function closeTracksModal(){
      closeTrackInfoModal({ suppressFocus: true });
      // stop playback when closing
      if (!player.paused) player.pause();
      updateButtonsForStop();
      currentSrc = '';
      overlay.classList.remove('open');
      overlay.setAttribute('aria-hidden', 'true');
      modalContent.innerHTML = '';
      modalCover.innerHTML = '';
      document.body.classList.remove('no-scroll');
        }

    function openTracksModal(album, sourceCard=null){
      // Ensure only one window open: close any existing
      closeTracksModal();
      const albumCard = sourceCard || null;
      if (albumCard) {
        albumCard.dataset.validTracks = '0';
        albumCard.dataset.pendingTracks = '0';
        if (albumCard.dataset.hasAudioCandidates === 'true') {
          albumCard.classList.remove('no-audio');
          if (albumCard.title === 'No playable audio available') albumCard.removeAttribute('title');
        } else {
          albumCard.classList.add('no-audio');
          if (!albumCard.title) albumCard.title = 'No playable audio available';
        }
      }

      // Fill header
      modalTitle.textContent = album.title || '(no album)';
      modalArtist.textContent = album.artist || '';
      modalCat.textContent = album.catalogue || '';
      if (!album.catalogue) modalCat.style.display = 'none'; else modalCat.style.display = 'inline-block';

      // Cover
      if (album.picture) {
        const wrap = document.createElement('div');
        wrap.className = 'cover-wrap';
        const img = document.createElement('img');
        img.src = `/api/container?u=${encodeURIComponent(album.picture)}`;
        img.alt = 'Cover';
        img.onerror = () => { modalCover.innerHTML = ''; };
        wrap.appendChild(img);
        modalCover.innerHTML = '';
        modalCover.appendChild(wrap);
        modalCover.style.display = 'block';
      } else {
        modalCover.innerHTML = '';
        modalCover.style.display = 'none';
      }

      // Build track list
      const ul = document.createElement('ul');
      ul.className = 'tracks';

      album.tracks.forEach((t, idx) => {
        const li = document.createElement('li');
        li.className = 'track';

        const top = document.createElement('div');
        top.className = 'track-top';

        const titleWrap = document.createElement('div');
        titleWrap.className = 'track-title';
        const name = document.createElement('div');
        name.className = 'name';
        const seqLabel = Number.isFinite(t.seq) ? `${t.seq}. ` : '';
        name.textContent = seqLabel + (t.name || `Track ${idx+1}`);
        titleWrap.appendChild(name);
        if (t.trackArtist) {
          const artistLine = document.createElement('div');
          artistLine.className = 'artist';
          artistLine.textContent = t.trackArtist;
          titleWrap.appendChild(artistLine);
        }

        top.appendChild(titleWrap);

        const controls = document.createElement('div');
        controls.className = 'controls';

        const btnPlay = document.createElement('button');
        btnPlay.className = 'btn small';
        const playableCandidate = resolvePlayableSrc(t.mp3);
        const canPlay = canValidateAudioSrc(playableCandidate);
        const playableSrc = canPlay ? playableCandidate : '';
        li._src = playableSrc;
        li._btn = btnPlay;
        li._card = albumCard;
        li._playlist = null;
        li._audioField = t.mp3Field || '';
        const baseMetaAlbum = { ...t };
        baseMetaAlbum.trackName = t.name || `Track ${idx + 1}`;
        baseMetaAlbum.trackArtist = t.trackArtist || album.artist || '';
        baseMetaAlbum.albumTitle = album.title || '';
        baseMetaAlbum.albumArtist = album.artist || '';
        baseMetaAlbum.playlistId = null;
        baseMetaAlbum.playlistName = '';
        baseMetaAlbum.picture = album.picture || '';
        baseMetaAlbum.source = 'album';
        baseMetaAlbum.catalogue = album.catalogue || '';
        baseMetaAlbum.audioField = t.mp3Field || '';
        baseMetaAlbum.trackRecordId = t.recordId || '';
        baseMetaAlbum.pictureField = album.pictureField || t.pictureField || '';
        baseMetaAlbum.src = playableSrc;
        li._meta = baseMetaAlbum;
        li._validated = false;
        li._valid = null;
        li._validating = false;
        if (canPlay) {
          btnPlay.textContent = '▶ Play';
          btnPlay.disabled = false;
          btnPlay.classList.remove('btn-error');
          btnPlay.removeAttribute('title');
        } else if (t.mp3) {
          btnPlay.textContent = 'Invalid audio';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.title = 'Invalid audio link';
        } else {
          btnPlay.textContent = 'No audio';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.title = 'Audio missing';
        }
        btnPlay.addEventListener('click', async () => {
          if (!li._src) return;
          if (li._valid === false) {
            btnPlay.textContent = 'Unavailable';
            btnPlay.disabled = true;
            btnPlay.classList.add('btn-error');
            return;
          }

          handlePlay(btnPlay, li, li._src);

          if (li._valid === true || li._validating) return;

          li._validating = true;
          validateAudio(li, li._src, { optimistic: true }).finally(() => {
            li._validating = false;
          });
        });
        controls.appendChild(btnPlay);

        const btnAdd = document.createElement('button');
        btnAdd.type = 'button';
        btnAdd.className = 'btn small';
        btnAdd.textContent = 'Add to playlist';
        btnAdd.addEventListener('click', () => handleAddToPlaylist(album, t, playableSrc));
        controls.appendChild(btnAdd);

        const hasInfo = Boolean(
          t.producer ||
          t.trackArtist ||
          t.composer1 ||
          t.composer2 ||
          t.composer3 ||
          t.composer4 ||
          (Array.isArray(t.composers) && t.composers.some(value => String(value || '').trim())) ||
          t.language ||
          t.genre ||
          t.isrc
        );
        if (hasInfo) {
          const infoBtn = document.createElement('button');
          infoBtn.type = 'button';
          infoBtn.className = 'btn small info-more';
          infoBtn.setAttribute('aria-label', 'More info');
          infoBtn.innerHTML = '<span aria-hidden="true">⋮</span>';
          infoBtn.addEventListener('click', () => openTrackInfoModal(t, infoBtn));
          controls.appendChild(infoBtn);
        }

        top.appendChild(controls);

        li.appendChild(top);

        // Progress UI (non-destructive)
        const progWrap = document.createElement('div');
        progWrap.className = 'progress';
        const seek = document.createElement('input');
        seek.type = 'range'; seek.className = 'seek'; seek.min = 0; seek.max = 100; seek.value = 0;
        const time = document.createElement('div');
        time.className = 'time'; time.textContent = '0:00 / 0:00';
        progWrap.appendChild(seek); progWrap.appendChild(time);
        li.appendChild(progWrap);
        li._seek = seek; li._time = time; li._seeking = false;
        // Seek while dragging (works while playing or paused)
        seek.addEventListener('input', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
        });
        seek.addEventListener('change', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
          li._seeking = false;
        });
        seek.addEventListener('pointerdown', () => { if (currentRow === li) li._seeking = true; });
        seek.addEventListener('pointerup',   () => { if (currentRow === li) li._seeking = false; });

        ul.appendChild(li);
      });

      modalContent.innerHTML = '';
      modalContent.appendChild(ul);

      // Open
      overlay.classList.add('open');
      overlay.setAttribute('aria-hidden', 'false');
      document.body.classList.add('no-scroll');
        }

    modalClose.addEventListener('click', closeTracksModal);
    overlay.addEventListener('click', (e) => {
      // Close if clicking backdrop (but not clicks inside the dialog)
      if (e.target === overlay) closeTracksModal();
        });
    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      if (overlay.classList.contains('open')) {
        closeTracksModal();
        return;
      }
      if (authOverlay && !authOverlay.hidden) {
        closeAuth();
      }
        });

    trackInfoOverlay.addEventListener('click', (e) => {
      if (e.target === trackInfoOverlay) closeTrackInfoModal();
        });
    trackInfoClose.addEventListener('click', () => closeTrackInfoModal());

    if (authOverlay) {
      authOverlay.addEventListener('click', (event) => {
        if (event.target === authOverlay) closeAuth();
      });
    }
    if (authClose) authClose.addEventListener('click', () => closeAuth());
    if (authForm) authForm.addEventListener('submit', submitAuthForm);
    if (authSwitch) {
      authSwitch.addEventListener('click', () => {
        const nextMode = authMode === 'login' ? 'register' : 'login';
        setAuthMode(nextMode);
        queueTask(() => authEmail?.focus());
      });
    }
    if (loginTrigger) {
      loginTrigger.addEventListener('click', () => openAuth('login', loginTrigger));
    }
    if (signupTrigger) {
      signupTrigger.addEventListener('click', () => openAuth('register', signupTrigger));
    }
    if (logoutButton) {
      logoutButton.addEventListener('click', performLogout);
    }
    if (playlistCreateForm) {
      playlistCreateForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!currentUser) {
          openAuth('login', playlistCreateForm.querySelector('button'));
          return;
        }
        const name = (playlistNameInput?.value || '').trim();
        if (!name) return;
        try {
          const playlist = await createPlaylistOnServer(name);
          if (playlistNameInput) playlistNameInput.value = '';
          if (playlist?.id) setActivePlaylist(playlist.id);
        } catch (err) {
          window.alert(err?.message || 'Unable to create playlist');
        }
      });
    }
    if (deletePlaylistButton) {
      deletePlaylistButton.addEventListener('click', () => {
        if (deletePlaylistButton.disabled) return;
        deleteActivePlaylist();
      });
    }
    if (togglePlaylistTracksButton) {
      togglePlaylistTracksButton.addEventListener('click', () => {
        playlistTracksCollapsed = !playlistTracksCollapsed;
        if (playlistTracksCollapsed && playlistTracksSection) playlistTracksSection.classList.remove('only-current');
        renderPlaylistTracks();
      });
    }
    if (nowPlayingCollapseButton) {
      nowPlayingCollapseButton.addEventListener('click', () => {
        nowPlayingCollapsed = !nowPlayingCollapsed;
        updateNowPlayingUI();
      });
    }
    if (nowPlayingToggleButton) {
      nowPlayingToggleButton.addEventListener('click', () => {
        if (!nowPlayingInfo.meta) return;
        const meta = nowPlayingInfo.meta;
        if (player.paused) {
          if (!currentRow && meta.playlistId && meta.playlistTrackId && playlistTracksList) {
            const candidate = playlistTracksList.querySelector(`[data-track-id="${meta.playlistTrackId}"]`);
            if (candidate) {
              currentRow = candidate;
              currentBtn = candidate._btn || null;
            }
          }
          if (meta.src && player.src !== meta.src) {
            player.src = meta.src;
            currentSrc = meta.src;
            player.currentTime = 0;
          }
          player.play()
            .then(() => {
              if (currentRow) {
                setNowPlayingFromRow(currentRow, true);
                if (currentRow._btn) {
                  currentBtn = currentRow._btn;
                  currentBtn.disabled = false;
                  currentBtn.textContent = '⏸ Pause';
                  currentBtn.classList.add('btn-accent');
                }
                currentRow.classList.remove('loading');
                currentRow.classList.add('playing');
                updateProgressUI();
              } else {
                setNowPlayingFromRow({ _meta: meta, _src: meta.src }, true);
              }
            })
            .catch((err) => {
              console.warn('Resume playback failed:', err);
              window.alert('Unable to resume playback.');
            });
        } else {
          player.pause();
        }
      });
    }

    setAuthMode('login');
    updateAuthUI();
    refreshCurrentUser();

    /* ================= Rendering albums (cards) ================= */
    function renderAlbumPage(){
      albumsEl.innerHTML = '';

      const validAlbums = [];
      const pendingQueue = [];
      let pendingAlbums = 0;

      for (const album of albumGroups) {
        if (!album) continue;
        const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
        album.key = key;
        const state = albumAudioState.get(key);
        if (!state) {
          ensureAlbumAudioValidation(album);
          pendingAlbums += 1;
          pendingQueue.push(album);
          continue;
        }
        if (state.status === 'pending') {
          album._pendingValidation = true;
          pendingAlbums += 1;
          pendingQueue.push(album);
          continue;
        }
        if (state.status === 'valid') {
          if (isFresh(state)) {
            album._pendingValidation = false;
            validAlbums.push(album);
          } else {
            albumAudioState.delete(key);
            ensureAlbumAudioValidation(album);
            pendingAlbums += 1;
            pendingQueue.push(album);
          }
          continue;
        }
        if (state.status === 'invalid') {
          if (!isFresh(state)) {
            albumAudioState.delete(key);
            ensureAlbumAudioValidation(album);
            pendingAlbums += 1;
            pendingQueue.push(album);
          }
        }
      }

      pendingAlbums = pendingQueue.length;

      const displayAlbums = validAlbums.concat(pendingQueue);
      const totalAlbums = displayAlbums.length;
      const availableAlbums = albumGroups.length || totalAlbums;

      if (availableAlbums > 0) {
        errorEl.hidden = true;
      } else if (pendingAlbums === 0 && albumGroups.length > 0) {
        errorEl.hidden = false;
        errorEl.textContent = 'No albums with complete audio and artwork are available right now.';
      } else if (pendingAlbums > 0) {
        errorEl.hidden = true;
      }

      if (totalAlbums === 0) {
        albumsEl.classList.remove('single-album');
      }

      if (totalAlbums === 0 && pendingAlbums > 0) {
        countEl.textContent = 'Validating audio…';
      } else {
        countEl.textContent = availableAlbums ? `Albums: ${availableAlbums}` : (lastQ ? 'No albums' : '');
      }

      const totalPool = Math.max(availableAlbums, displayAlbums.length);
      const maxPage = Math.max(1, Math.ceil(Math.max(totalPool, 1) / ALBUMS_PER_PAGE));
      albumPage = Math.min(albumPage, maxPage - 1);
      pagerEl.hidden = totalPool <= ALBUMS_PER_PAGE;
      pageInfo.textContent = `Page ${albumPage + 1} / ${maxPage}`;
      prevEl.disabled = albumPage <= 0;
      nextEl.disabled = albumPage >= maxPage - 1 && rawItems.length >= rawTotalFound;

      if (totalAlbums === 0 && pendingAlbums > 0) {
        const wait = document.createElement('div');
        wait.className = 'muted';
        wait.textContent = 'Validating audio availability…';
        albumsEl.appendChild(wait);
        return;
      }

      if (totalAlbums === 0) {
        return;
      }

      const start = albumPage * ALBUMS_PER_PAGE;
      const end = Math.min(start + ALBUMS_PER_PAGE, totalAlbums);
      const pageAlbums = displayAlbums.slice(start, end);

      if (pageAlbums.length === 1) {
        albumsEl.classList.add('single-album');
      } else {
        albumsEl.classList.remove('single-album');
      }

      pageAlbums.forEach(album => {
        const card = document.createElement('div');
        card.className = 'card';
        const candidateTracks = Array.isArray(album.tracks) ? album.tracks.filter(track => hasValidMp3(track.mp3)) : [];
        const hasPlayable = album && album.hasPlayable;
        const hasCandidates = hasPlayable !== undefined ? hasPlayable : candidateTracks.length > 0;
        card.dataset.hasAudioCandidates = hasCandidates ? 'true' : 'false';
        card.dataset.validTracks = '0';
        card.dataset.pendingTracks = album._pendingValidation ? '1' : '0';
        if (hasCandidates) {
          card.classList.remove('no-audio');
          card.removeAttribute('title');
        } else {
          card.classList.add('no-audio');
          card.title = 'No playable audio available';
        }

        if (album._pendingValidation) {
          card.classList.add('pending-audio');
          if (!card.title) card.title = 'Validating audio availability…';
        }

        if (totalAlbums === 1 && prevSearch) {
          const backWrap = document.createElement('div');
          backWrap.className = 'back-row';
          const backBtn = document.createElement('button');
          backBtn.type = 'button';
          backBtn.className = 'btn small';
          backBtn.textContent = prevSearch.type === 'explore' ? 'Back to explore results' : 'Back to search results';
          backBtn.addEventListener('click', () => restorePreviousSearch());
          backWrap.appendChild(backBtn);
          card.appendChild(backWrap);
        }



        if (album.picture) {
          const proxied = `/api/container?u=${encodeURIComponent(album.picture)}`;
          const wrap = document.createElement('div');
          wrap.className = 'cover-wrap';
          const img = document.createElement('img');
          img.src = proxied;
          img.alt = 'Cover';
          img.onerror = () => { wrap.remove(); };
          wrap.appendChild(img);
          wrap.tabIndex = 0;
          wrap.setAttribute('role','button');
          try { wrap.setAttribute('aria-label', `Open tracks for ${album.title}`); } catch {}
          const triggerSearch = () => {
            if (totalAlbums > 1) {
              const term = album.title || '';
              if (searchEl) searchEl.value = term;
              run(term);
            } else {
              openTracksModal(album, card);
            }
          };
          wrap.addEventListener('click', triggerSearch);
          wrap.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ' ) {
              e.preventDefault();
              triggerSearch();
            }
          });
          card.appendChild(wrap);
        }

        const heading = document.createElement('div');
        heading.className = 'heading';
        const h3 = document.createElement('h3');
        h3.textContent = album.title;
        heading.appendChild(h3);

        if (album.catalogue) {
          const cat = document.createElement('span');
          cat.className = 'badge';
          cat.textContent = album.catalogue;
          heading.appendChild(cat);
        }
        card.appendChild(heading);

        const muted = document.createElement('div');
        muted.className = 'muted';
        muted.textContent = album.artist;
        card.appendChild(muted);

        const toggle = document.createElement('button');
        toggle.className = 'btn small';
        toggle.textContent = `Show Tracks (${album.tracks.length})`;
        toggle.addEventListener('click', () => openTracksModal(album, card));
        card.appendChild(toggle);

        albumsEl.appendChild(card);
      });
    }

    function updateProgressUI(){
      if (!currentRow) return;
      const seek = currentRow._seek, time = currentRow._time;
      if (!seek || !time) return;
      const dur = player.duration, cur = player.currentTime;
      const pct = (dur && isFinite(dur)) ? Math.min(100, Math.max(0, (cur/dur)*100)) : 0;
      if (!(currentRow && currentRow._seeking)) { seek.value = String(pct); seek.style.setProperty('--fill', pct + '%'); }
      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = pct + '%';
      }
      time.textContent = fmtTime(cur) + ' / ' + fmtTime(dur);
        }

    function handlePlay(btn, row, src){
      if (!src) return;
      if (currentSrc === src && !player.paused) {
        player.pause();
        updateButtonsForStop();
        return;
      }

      if (currentSrc !== src) {
        player.src = src;
      }
      currentSrc = src;

      updateButtonsForStop();
      setNowPlayingFromRow(row, false);

      currentBtn = btn;
      currentRow = row;
      if (currentRow) {
        currentRow.classList.remove('playing');
        currentRow.classList.add('loading');
      }
      btn.disabled = true;
      btn.textContent = 'Loading…';
      btn.classList.add('btn-accent');
      btn.classList.remove('btn-error');

      player.play()
        .then(() => {
          updateButtonsForStop();
          currentBtn = btn;
          currentRow = row;
          if (currentRow) {
            currentRow.classList.remove('loading');
            currentRow.classList.add('playing');
          }
          btn.disabled = false;
          btn.textContent = '⏸ Pause';
          btn.classList.add('btn-accent');
          updateProgressUI();
          scheduleNextTrackPreload(currentRow);
          setNowPlayingFromRow(row, true);
        })
        .catch((err) => {
          console.warn('Playback error:', err);
          try {
            player.removeAttribute('src');
            player.load();
          } catch {}
          currentSrc = '';
          updateButtonsForStop();
          markNowPlayingInactive();
        });
    }
    function updateButtonsForStop(){
      if (currentRow) {
        currentRow.classList.remove('playing');
        currentRow.classList.remove('loading');
      }
      if (currentBtn) {
        currentBtn.disabled = false;
        currentBtn.textContent = '▶ Play';
        currentBtn.classList.remove('btn-accent');
      }
      currentBtn = null; currentRow = null;
      markNowPlayingInactive();
      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = '0%';
      }
        }
    function playNextTrackFromPlaylistMeta(meta){
      if (!meta || !meta.playlistId) return false;
      const playlist = playlists.find((p) => p && p.id === meta.playlistId);
      if (!playlist) return false;
      const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
      if (!tracks.length) return false;

      const currentIdx = tracks.findIndex((t) => {
        if (!t) return false;
        if (meta.playlistTrackId && t.id === meta.playlistTrackId) return true;
        if (meta.trackRecordId && t.trackRecordId === meta.trackRecordId) return true;
        return false;
      });

      let nextCandidate = null;
      for (let i = currentIdx + 1; i < tracks.length; i++) {
        const candidate = tracks[i];
        if (!candidate) continue;
        const raw = candidate.resolvedSrc || candidate.mp3 || '';
        if (canValidateAudioSrc(resolvePlayableSrc(raw))) {
          nextCandidate = candidate;
          break;
        }
      }
      if (!nextCandidate) return false;

      if (activePlaylistId !== playlist.id) {
        activePlaylistId = playlist.id;
        playlistTracksCollapsed = false;
        renderPlaylistsPanel();
      } else if (!playlistTracksList || !playlistTracksList.children.length) {
        renderPlaylistTracks();
      }

      if (!playlistTracksList) return false;

      const selectors = [];
      if (nextCandidate.id) selectors.push('[data-track-id="' + nextCandidate.id + '"]');
      if (nextCandidate.trackRecordId) selectors.push('[data-track-id="' + nextCandidate.trackRecordId + '"]');

      let nextRow = null;
      for (const sel of selectors) {
        nextRow = playlistTracksList.querySelector(sel);
        if (nextRow) break;
      }
      if (!nextRow) {
        nextRow = playlistTracksList.querySelector('.playlist-track');
        while (nextRow && !nextRow._src) {
          nextRow = findNextPlayableRow(nextRow);
        }
      }

      if (nextRow && nextRow._btn && nextRow._src) {
        handlePlay(nextRow._btn, nextRow, nextRow._src);
        return true;
      }
      return false;
        }

    function playNextPlayableFrom(anchor){
      if (!anchor) return false;
      let candidate = findNextPlayableRow(anchor);
      while (candidate && !candidate._src) {
        candidate = findNextPlayableRow(candidate);
      }
      if (candidate && candidate._btn && candidate._src) {
        handlePlay(candidate._btn, candidate, candidate._src);
        return true;
      }
      return false;
        }

    player.addEventListener('ended', () => {
      const nextLi = currentRow ? findNextPlayableRow(currentRow) : null;
      if (nextLi && nextLi._btn && nextLi._src) {
        handlePlay(nextLi._btn, nextLi, nextLi._src);
        return;
      }

      // Fallback: attempt to locate the next playlist item if the DOM was re-rendered
      if (!nextLi && nowPlayingInfo.meta?.playlistId && playlistTracksList) {
        const selector = nowPlayingInfo.meta.playlistTrackId
          ? `[data-track-id="${nowPlayingInfo.meta.playlistTrackId}"]`
          : null;
        let anchor = selector ? playlistTracksList.querySelector(selector) : null;
        if (!anchor && currentRow && currentRow._playlist === nowPlayingInfo.meta.playlistId) {
          anchor = currentRow;
        }
        if (!anchor) {
          const first = playlistTracksList.querySelector('.playlist-track');
          anchor = first || null;
        }
        if (anchor) {
          let candidate = findNextPlayableRow(anchor);
          while (candidate && !candidate._src) {
            candidate = findNextPlayableRow(candidate);
          }
          if (candidate && candidate._btn && candidate._src) {
            handlePlay(candidate._btn, candidate, candidate._src);
            return;
          }
        }
      }
      if (playNextTrackFromPlaylistMeta(nowPlayingInfo.meta)) {
        return;
      }

      updateButtonsForStop();
      currentSrc = '';
      updateProgressUI();
      markNowPlayingInactive();
      if (nowPlayingProgressFill) nowPlayingProgressFill.style.width = '0%';
    });
    player.addEventListener('timeupdate', () => { updateProgressUI(); });
    player.addEventListener('loadedmetadata', () => { updateProgressUI(); });
    player.addEventListener('pause', () => {
      if (currentBtn && currentSrc === player.src) {
        currentBtn.textContent = '▶ Play';
        currentBtn.classList.remove('btn-accent');
        if (currentRow) currentRow.classList.remove('playing');
      }
      markNowPlayingInactive();
        });
    player.addEventListener('play', () => {
      if (currentRow) setNowPlayingFromRow(currentRow, true);
    });
    player.addEventListener('error', () => {
      const err = player.error;
      if (err) {
        console.warn('[MASS] Audio element error', { code: err.code, message: err.message });
      } else {
        console.warn('[MASS] Audio element encountered an unknown error');
      }
    });

    /* ================= Lazy-load FM rows ================= */
    async function loadMore(q){
      showBusy('Loading more…');
      try {
        if (rawItems.length >= rawTotalFound) return false; // nothing left
        const params = new URLSearchParams();
        if (q) params.set('q', q);
        params.set('offset', rawNextOffset);
        params.set('limit', FM_FETCH_LIMIT);
        const r = await fetch(`/api/search?${params}`);
        if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`));
        const j = await r.json();
        const newItems = j.items || [];
        rawItems = rawItems.concat(newItems);
        rawTotalFound = Number(j.total || rawTotalFound);
        const returnedOffset = Number(j.offset || 0);
        rawNextOffset = returnedOffset + newItems.length;
        albumGroups = groupAlbums(rawItems);
        primeAlbumAudioValidation(albumGroups);
        return newItems.length > 0;
      } finally {
        hideBusy();
      }
        }
    /* ================= Search & paging ================= */
    function shuffleInPlace(arr){
      for(let i=arr.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; }
        }

    async function runExplore(startYear){
      const restoringThisRun = isRestoring;
      if (!isRestoring) {
        if (albumGroups.length || rawItems.length) {
          const snapshot = snapshotState();
          prevSearch = { type: snapshot.mode || currentMode, start: startYear, snapshot };
        } else {
          prevSearch = null;
        }
      }
      showBusy(`Loading ${startYear}s…`);
      hideLanding();
      // small guard
      const start = Number(startYear)||0;
      if(!start){
        if (restoringThisRun) isRestoring = false;
        return;
      }
      const end = start + 9;
      const params = new URLSearchParams();
      params.set('start', String(start));
      params.set('end',   String(end));
      params.set('limit', '120'); // quick; let UI group & sample
      try {
        const r = await fetch(`/api/explore?${params}`);
        if (!r.ok) {
          errorEl.hidden = false;
          errorEl.textContent = 'Explore error: ' + await r.text();
          return;
        }

        const j = await r.json();
        if (!j || !Array.isArray(j.items) || j.items.length === 0){
          errorEl.hidden = false;
          errorEl.textContent = `No albums found for the ${start}s.`;
          rawItems = [];
          rawTotalFound = 0;
          rawNextOffset = 0;
          albumGroups = [];
          albumPage = 0;
          renderAlbumPage();
          return;
        }

        rawItems = j.items || [];
        rawTotalFound = Number(j.total || rawItems.length);
        rawNextOffset = 0;
        albumGroups = groupAlbums(rawItems).filter(album => (album.picture || '').trim());
        primeAlbumAudioValidation(albumGroups);
        currentMode = 'explore';
        if (!albumGroups.length) {
          errorEl.hidden = false;
          errorEl.textContent = `No albums with complete audio and artwork found for the ${start}s.`;
          rawItems = [];
          rawTotalFound = 0;
          renderAlbumPage();
          return;
        }
        shuffleInPlace(albumGroups);
        if (albumGroups.length > ALBUMS_PER_PAGE) {
          albumGroups = albumGroups.slice(0, ALBUMS_PER_PAGE);
        }
        rawItems = albumGroups;
        rawTotalFound = albumGroups.length;
        albumPage = 0;
        renderAlbumPage();
      } finally {
        hideBusy();
        if (restoringThisRun) isRestoring = false;
      }
        }

    // Build decade chips and toggle
    if (decadeButtonsEl){
      const decades = [1950,1960,1970,1980,1990,2000,2010,2020];
      decadeButtonsEl.innerHTML = '';
      for (const d of decades) {
        const b = document.createElement('button');
        b.textContent = d + 's';
        b.addEventListener('click', () => runExplore(d));
        decadeButtonsEl.appendChild(b);
      }
        }
    if (exploreEl && decadeButtonsEl){
      exploreEl.setAttribute('aria-expanded', decadeButtonsEl.hasAttribute('hidden') ? 'false' : 'true');
      exploreEl.addEventListener('click', () => {
        const hidden = decadeButtonsEl.hasAttribute('hidden');
        if (hidden) {
          decadeButtonsEl.removeAttribute('hidden');
          exploreEl.setAttribute('aria-expanded', 'true');
        } else {
          decadeButtonsEl.setAttribute('hidden', '');
          exploreEl.setAttribute('aria-expanded', 'false');
        }
      });
        }
    function run(q){
      if(!q){
        showLanding();
        if (isRestoring) isRestoring = false;
        return;
      } // keep everything else untouched; only search when user types
      const restoringThisRun = isRestoring;
      if (!isRestoring) {
        const hasPrevious = albumGroups.length || rawItems.length;
        if (hasPrevious) {
          const previousTerm = lastQ;
          const snapshot = snapshotState({ lastQ: previousTerm, searchValue: previousTerm });
          prevSearch = { type: snapshot.mode || currentMode, term: previousTerm, snapshot };
        } else {
          prevSearch = null;
        }
      }
      lastQ = q;
      albumsEl.classList.remove('single-album');
      hideLanding();
      showBusy('Searching…');
      doSearch(q)
        .then(json => {
          rawItems = json?.items || [];
          rawTotalFound = Number(json?.total || rawItems.length);
          rawNextOffset = Number(json?.offset || 0) + rawItems.length;

          albumGroups = groupAlbums(rawItems);
          primeAlbumAudioValidation(albumGroups);
          albumPage = 0;
          currentMode = 'search';
          renderAlbumPage();
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          errorEl.hidden = false;
          errorEl.textContent = `Search error: ${err.message || err}`;
        })
        .finally(() => {
          hideBusy();
          if (restoringThisRun) isRestoring = false;
        });
        }

    goEl.addEventListener('click', () => { const q = searchEl.value.trim(); run(q); });
    if (searchEl) {
      searchEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          goEl.click();
        }
      });
        }
    clearEl.addEventListener('click', () => { searchEl.value=''; showLanding(); });

    prevEl.addEventListener('click', () => {
      if (albumPage>0){ albumPage--; renderAlbumPage(); }
        });
    nextEl.addEventListener('click', async () => {
      const maxPage = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      // If at the last page but FM has more rows, fetch next chunk first
      if (albumPage >= maxPage - 1 && rawItems.length < rawTotalFound) {
        nextEl.disabled = true;
        try { await loadMore(lastQ); } finally { nextEl.disabled = false; }
      }
      const newMax = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      if (albumPage < newMax - 1) { albumPage++; renderAlbumPage(); }
      else { renderAlbumPage(); }
        });

    // Initial load — show placeholder image; search begins only after typing
    showLanding();
  </script>
</body>
</html>
